import get from 'get-value';
import { Utils, GENERIC_KEY_SCHEMA } from './utils.js';
import { Transmitter } from './transmitter.js';
import { Packet } from './packet.js';
import { World } from './world.js';
const { set } = Utils;
class Room {
    constructor() {
        this.memoryTotalObject = {};
        this.memoryObject = {};
        this.permanentObject = [];
    }
    static hasExtraProp(obj) {
        return obj.$default !== undefined ||
            obj.$syncWithClient !== undefined ||
            obj.$permanent !== undefined ||
            obj.$validate !== undefined ||
            obj.$effects !== undefined;
    }
    static toDict(schema, room) {
        const dict = {};
        const permanentObject = [];
        function toDict(obj, path = '') {
            for (let prop in obj) {
                const val = obj[prop];
                let p = (path ? path + '.' : '') + prop;
                if (Array.isArray(val)) {
                    dict[p] = GENERIC_KEY_SCHEMA;
                    p += '.' + GENERIC_KEY_SCHEMA;
                    dict[p] = val[0];
                    toDict(val[0], p);
                }
                else if (Utils.isObject(val)) {
                    if (Room.hasExtraProp(val)) {
                        if (val.$permanent ?? true)
                            permanentObject.push(p);
                        if (room && val.$default !== undefined) {
                            // TODO
                            //set(room, p, val.$default)
                        }
                        if (val.$syncWithClient === false) {
                            continue;
                        }
                        // Force to take a type (number here - not important) and not object. Otherwise, Proxy will traverse this object from 
                        dict[p] = {
                            ...val
                        };
                    }
                    else {
                        dict[p] = val;
                        toDict(val, p);
                    }
                }
                else {
                    permanentObject.push(p);
                    dict[p] = val;
                }
            }
        }
        toDict(schema);
        return {
            dict,
            permanentObject
        };
    }
    join(user, room) {
        if (!user._rooms)
            user._rooms = [];
        user._rooms.push(room.id);
        if (!user.id)
            user.id = Utils.generateId();
        if (room['onJoin'])
            room['onJoin'](user);
        //
        if (this.getUsersLength(room) == 1) {
            // If it's the first to arrive in the room, we save the default values of the room
            this.memoryTotalObject = Room.extractObjectOfRoom(room, room.$schema);
        }
        const packet = new Packet({
            ...this.memoryTotalObject,
            join: true
        }, room.id);
        Transmitter.emit(user, packet, room);
    }
    leave(user, room) {
        const index = user._rooms.findIndex(id => room.id == id);
        user._rooms.splice(index, 1);
        if (room['onLeave'])
            room['onLeave'](user);
    }
    getUsersLength(room) {
        return Object.keys(room.users).length;
    }
    addInputs(room, obj) {
        room.$schema = {
            ...obj,
            ...room.$schema
        };
    }
    snapshotUser(room, userId) {
        const userSchema = this.permanentObject
            .filter(path => path.startsWith('users.@'))
            .map(path => path.replace('users.@.', ''));
        const userObject = room.users[userId];
        if (!userObject)
            return null;
        return Room.extractObjectOfRoom(userObject, userSchema);
    }
    snapshot(room) {
        return Room.extractObjectOfRoom(room, this.permanentObject);
    }
    setProxy(room) {
        const self = this;
        const { dict, permanentObject } = Room.toDict(room.$schema, room);
        this.permanentObject = permanentObject;
        room.$dict = dict;
        const getInfoDict = (path, key, dictPath) => {
            const basePath = dict[dictPath];
            const p = (path ? path + '.' : '') + key;
            const genericPath = (dictPath ? dictPath + '.' : '') +
                (basePath == GENERIC_KEY_SCHEMA ? GENERIC_KEY_SCHEMA : key);
            return {
                fullPath: p,
                genericPath,
                infoDict: dict[genericPath]
            };
        };
        function deepProxy(object, path = '', dictPath = '') {
            return new Proxy(object, {
                set(target, key, val, receiver) {
                    const { fullPath: p, infoDict, genericPath } = getInfoDict(path, key, dictPath);
                    // TODO: block set if deleted. Not apply in player
                    // if (target._isDeleted) {
                    //     return false
                    // }
                    if (typeof val == 'object' && infoDict && val != null) {
                        const valProxy = deepProxy(val, p, genericPath);
                        if (path == 'users') {
                            World.users[key]['proxy'] = valProxy;
                        }
                        Reflect.set(target, key, valProxy, receiver);
                        val = target[key];
                    }
                    else {
                        if (infoDict?.$validate) {
                            const { error } = infoDict.$validate.validate(val);
                            if (error)
                                return true;
                        }
                        Reflect.set(target, key, val, receiver);
                        val = target[key]; // Reflect calls the modifiers, so we get the new value
                    }
                    if (key == 'length' && dict[dictPath] == GENERIC_KEY_SCHEMA) {
                        return true;
                    }
                    if (infoDict) {
                        if (infoDict.$effects) {
                            for (let propEffect of infoDict.$effects) {
                                let pathEffect = '';
                                if (propEffect.startsWith('$this')) {
                                    // replace last property in string. Example: users.test.name by users.test.fullname
                                    if (p) {
                                        const pSplit = p.split('.');
                                        pSplit[pSplit.length - 1] = propEffect.replace('$this.', '');
                                        pathEffect = pSplit.join('.');
                                    }
                                    else {
                                        pathEffect = propEffect.replace('$this.', '');
                                    }
                                }
                                else {
                                    pathEffect = propEffect;
                                }
                                self.editMemoryObject(pathEffect, room);
                            }
                        }
                        let newObj;
                        if (Utils.isObject(infoDict) && val != null && !Room.hasExtraProp(infoDict)) {
                            newObj = Room.extractObjectOfRoom(val, infoDict);
                        }
                        else if (infoDict == GENERIC_KEY_SCHEMA) {
                            newObj = {};
                            // reset the object
                            if (Object.keys(val).length == 0) {
                                newObj['$reset'] = true;
                            }
                            for (let key in val) {
                                const item = val[key];
                                if (typeof item == 'string' ||
                                    typeof item == 'number' ||
                                    typeof item == 'boolean') {
                                    newObj[key] = item;
                                    continue;
                                }
                                newObj[key] = Room.extractObjectOfRoom(item, dict[genericPath + '.' + GENERIC_KEY_SCHEMA]);
                            }
                        }
                        else {
                            newObj = val;
                        }
                        self.detectChanges(room, newObj, p);
                    }
                    return true;
                },
                get(target, key, receiver) {
                    const toProxy = (val, path) => {
                        if (typeof key != 'string') {
                            return val;
                        }
                        if (key[0] == '_' || val == null) {
                            return val;
                        }
                        const { fullPath: p, infoDict, genericPath } = getInfoDict(path, key, dictPath);
                        if (typeof val == 'object' && infoDict) {
                            val = deepProxy(val, p, genericPath);
                        }
                        return val;
                    };
                    let val = Reflect.get(target, key, receiver);
                    val = toProxy(val, path);
                    return val;
                },
                deleteProperty(target, key) {
                    const { fullPath: p, infoDict } = getInfoDict(path, key, dictPath);
                    //target[key]._isDeleted = true
                    Reflect.deleteProperty(target, key);
                    if (infoDict)
                        self.detectChanges(room, null, p);
                    return true;
                }
            });
        }
        return deepProxy(room);
    }
    add(id, room) {
        room.id = id;
        room.$dict = {};
        if (!room.$schema)
            room.$schema = {};
        if (!room.$schema.users)
            room.$schema.users = [{ id: String }];
        if (!room.$inputs)
            room.$inputs = {};
        if (!room.users)
            room.users = {};
        if (room.$inputs)
            this.addInputs(room, room.$inputs);
        room.$detectChanges = () => {
            //this.detectChanges(room)
        };
        room.$setSchema = (schema) => {
            room.$schema = schema;
            return this.setProxy(room);
        };
        room.$patchSchema = (schema) => {
            room.$schema = {
                ...room.$schema,
                ...schema
            };
            return this.setProxy(room);
        };
        room.$snapshot = () => {
            return this.snapshot(room);
        };
        room.$snapshotUser = (userId) => {
            return this.snapshotUser(room, userId);
        };
        room.$join = (user) => {
            if (user) {
                room.users[user.id] = user;
                this.join(room.users[user.id], room);
            }
        };
        room.$leave = (user) => {
            this.leave(user, room);
            delete room.users[user.id];
            delete World.users[user.id]['proxy'];
            //this.detectChanges(room)
        };
        room.$currentState = () => this.memoryObject;
        room.$setCurrentState = (path, value) => {
            this.editMemoryObject(path, value === undefined ? room : value);
        };
        room.$clearCurrentState = () => {
            this.memoryObject = {};
        };
        this.proxyRoom = room = this.setProxy(room);
        if (this.proxyRoom['onInit'])
            this.proxyRoom['onInit']();
        return this.proxyRoom;
    }
    static extractObjectOfRoom(room, schema) {
        const newObj = {};
        const schemas = [];
        const _schema = Array.isArray(schema) ? schema : Utils.propertiesToArray(schema);
        function extract(path) {
            const match = new RegExp('^(.*?)\\.\\' + GENERIC_KEY_SCHEMA).exec(path);
            if (match) {
                const generic = get(room, match[1]);
                if (generic) {
                    const keys = Object.keys(generic);
                    for (let key of keys) {
                        extract(path.replace(GENERIC_KEY_SCHEMA, key));
                    }
                }
            }
            else {
                schemas.push(path);
            }
        }
        for (let path of _schema) {
            extract(path);
        }
        for (let sheme of schemas) {
            set(newObj, sheme, get(room, sheme));
        }
        return newObj;
    }
    detectChanges(room, obj, path) {
        // If after changing a room, we continue to use the wrong player instance, we ignore the changes made on an old proxy 
        if (obj != null) {
            const [prop, userId] = path.split('.');
            if (prop == 'users') {
                if (!room.users[userId]) {
                    return;
                }
            }
        }
        this.editMemoryObject(path, obj);
        set(this.memoryTotalObject, path, obj);
        if (this.proxyRoom['onChanges'])
            this.proxyRoom['onChanges'](this.memoryObject);
        const id = room.id;
        World.changes.next({
            ...World.changes.value,
            [id]: room
        });
    }
    editMemoryObject(path, roomOrValue) {
        if (roomOrValue && typeof roomOrValue == 'object' && '$currentState' in roomOrValue) {
            set(this.memoryObject, path, get(roomOrValue, path), true);
        }
        else {
            set(this.memoryObject, path, roomOrValue, true);
        }
    }
}
Room.propNameUsers = 'users';
export { Room };
//# sourceMappingURL=room.js.map