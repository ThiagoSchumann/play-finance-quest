(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("@rpgjs/common"), require("@rpgjs/server"), require("@rpgjs/client")) : typeof define === "function" && define.amd ? define(["exports", "@rpgjs/common", "@rpgjs/server", "@rpgjs/client"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.RpgStandalone = {}, global.common, global.server, global.client));
})(this, function(exports2, common, server, client) {
  "use strict";
  const {
    ClientIo,
    serverIo
  } = common.MockIo;
  function entryPoint(modules, options = {}) {
    const io = new ClientIo();
    class StandaloneGame {
      async start() {
        this.server = await server.entryPoint(modules, {
          io: serverIo,
          standalone: true,
          basePath: "",
          globalConfig: options.globalConfigServer,
          ...options
        });
        this.client = client.entryPoint(modules, {
          standalone: true,
          io,
          globalConfig: options.globalConfigClient,
          ...options
        });
        await this.server.start();
        await this.client.start();
        return this;
      }
      setHooks(hooks, side) {
        if (!common.Utils.isArray(hooks))
          modules.push({
            [side]: hooks
          });
        else
          modules.concat(hooks.map((hook) => {
            return {
              [side]: hook
            };
          }));
      }
      logicHooks(serverHooks) {
        this.setHooks(serverHooks, "server");
      }
      renderHooks(clientHooks) {
        this.setHooks(clientHooks, "client");
      }
    }
    return new StandaloneGame();
  }
  exports2.entryPoint = entryPoint;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
});
