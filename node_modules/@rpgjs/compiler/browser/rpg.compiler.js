const _e = {
  existsSync: (...e) => window.fs.existsSync(...e),
  readFileSync: (...e) => window.fs.readFileSync(...e),
  readdirSync: (...e) => window.fs.readdirSync(...e),
  copyFileSync: (...e) => window.fs.copyFileSync(...e)
};
function lo(e, t) {
  for (var r = 0, n = e.length - 1; n >= 0; n--) {
    var s = e[n];
    s === "." ? e.splice(n, 1) : s === ".." ? (e.splice(n, 1), r++) : r && (e.splice(n, 1), r--);
  }
  if (t)
    for (; r--; r)
      e.unshift("..");
  return e;
}
var Ma = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Pn = function(e) {
  return Ma.exec(e).slice(1);
};
function hn() {
  for (var e = "", t = !1, r = arguments.length - 1; r >= -1 && !t; r--) {
    var n = r >= 0 ? arguments[r] : "/";
    if (typeof n != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    if (!n)
      continue;
    e = n + "/" + e, t = n.charAt(0) === "/";
  }
  return e = lo(On(e.split("/"), function(s) {
    return !!s;
  }), !t).join("/"), (t ? "/" : "") + e || ".";
}
function fo(e) {
  var t = po(e), r = Ka(e, -1) === "/";
  return e = lo(On(e.split("/"), function(n) {
    return !!n;
  }), !t).join("/"), !e && !t && (e = "."), e && r && (e += "/"), (t ? "/" : "") + e;
}
function po(e) {
  return e.charAt(0) === "/";
}
function Fa() {
  var e = Array.prototype.slice.call(arguments, 0);
  return fo(On(e, function(t, r) {
    if (typeof t != "string")
      throw new TypeError("Arguments to path.join must be strings");
    return t;
  }).join("/"));
}
function Ua(e, t) {
  e = hn(e).substr(1), t = hn(t).substr(1);
  function r(i) {
    for (var u = 0; u < i.length && i[u] === ""; u++)
      ;
    for (var l = i.length - 1; l >= 0 && i[l] === ""; l--)
      ;
    return u > l ? [] : i.slice(u, l - u + 1);
  }
  for (var n = r(e.split("/")), s = r(t.split("/")), o = Math.min(n.length, s.length), a = o, c = 0; c < o; c++)
    if (n[c] !== s[c]) {
      a = c;
      break;
    }
  for (var f = [], c = a; c < n.length; c++)
    f.push("..");
  return f = f.concat(s.slice(a)), f.join("/");
}
var za = "/", Va = ":";
function La(e) {
  var t = Pn(e), r = t[0], n = t[1];
  return !r && !n ? "." : (n && (n = n.substr(0, n.length - 1)), r + n);
}
function qa(e, t) {
  var r = Pn(e)[2];
  return t && r.substr(-1 * t.length) === t && (r = r.substr(0, r.length - t.length)), r;
}
function Ha(e) {
  return Pn(e)[3];
}
const me = {
  extname: Ha,
  basename: qa,
  dirname: La,
  sep: za,
  delimiter: Va,
  relative: Ua,
  join: Fa,
  isAbsolute: po,
  normalize: fo,
  resolve: hn
};
function On(e, t) {
  if (e.filter)
    return e.filter(t);
  for (var r = [], n = 0; n < e.length; n++)
    t(e[n], n, e) && r.push(e[n]);
  return r;
}
var Ka = "ab".substr(-1) === "b" ? function(e, t, r) {
  return e.substr(t, r);
} : function(e, t, r) {
  return t < 0 && (t = e.length + t), e.substr(t, r);
};
const Ba = (e) => window.imagesLoaded[e];
var Ga = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ho(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var rr = {}, Ja = {
  get exports() {
    return rr;
  },
  set exports(e) {
    rr = e;
  }
}, mo = {}, Ie = {}, Ct = {}, ir = {}, W = {}, nr = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
  class t {
  }
  e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class r extends t {
    constructor(E) {
      if (super(), !e.IDENTIFIER.test(E))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = E;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  e.Name = r;
  class n extends t {
    constructor(E) {
      super(), this._items = typeof E == "string" ? [E] : E;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return !1;
      const E = this._items[0];
      return E === "" || E === '""';
    }
    get str() {
      var E;
      return (E = this._str) !== null && E !== void 0 ? E : this._str = this._items.reduce((O, j) => `${O}${j}`, "");
    }
    get names() {
      var E;
      return (E = this._names) !== null && E !== void 0 ? E : this._names = this._items.reduce((O, j) => (j instanceof r && (O[j.str] = (O[j.str] || 0) + 1), O), {});
    }
  }
  e._Code = n, e.nil = new n("");
  function s(m, ...E) {
    const O = [m[0]];
    let j = 0;
    for (; j < E.length; )
      c(O, E[j]), O.push(m[++j]);
    return new n(O);
  }
  e._ = s;
  const o = new n("+");
  function a(m, ...E) {
    const O = [b(m[0])];
    let j = 0;
    for (; j < E.length; )
      O.push(o), c(O, E[j]), O.push(o, b(m[++j]));
    return f(O), new n(O);
  }
  e.str = a;
  function c(m, E) {
    E instanceof n ? m.push(...E._items) : E instanceof r ? m.push(E) : m.push(l(E));
  }
  e.addCodeArg = c;
  function f(m) {
    let E = 1;
    for (; E < m.length - 1; ) {
      if (m[E] === o) {
        const O = i(m[E - 1], m[E + 1]);
        if (O !== void 0) {
          m.splice(E - 1, 3, O);
          continue;
        }
        m[E++] = "+";
      }
      E++;
    }
  }
  function i(m, E) {
    if (E === '""')
      return m;
    if (m === '""')
      return E;
    if (typeof m == "string")
      return E instanceof r || m[m.length - 1] !== '"' ? void 0 : typeof E != "string" ? `${m.slice(0, -1)}${E}"` : E[0] === '"' ? m.slice(0, -1) + E.slice(1) : void 0;
    if (typeof E == "string" && E[0] === '"' && !(m instanceof r))
      return `"${m}${E.slice(1)}`;
  }
  function u(m, E) {
    return E.emptyStr() ? m : m.emptyStr() ? E : a`${m}${E}`;
  }
  e.strConcat = u;
  function l(m) {
    return typeof m == "number" || typeof m == "boolean" || m === null ? m : b(Array.isArray(m) ? m.join(",") : m);
  }
  function w(m) {
    return new n(b(m));
  }
  e.stringify = w;
  function b(m) {
    return JSON.stringify(m).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  e.safeStringify = b;
  function h(m) {
    return typeof m == "string" && e.IDENTIFIER.test(m) ? new n(`.${m}`) : s`[${m}]`;
  }
  e.getProperty = h;
  function y(m) {
    if (typeof m == "string" && e.IDENTIFIER.test(m))
      return new n(`${m}`);
    throw new Error(`CodeGen: invalid export name: ${m}, use explicit $id name mapping`);
  }
  e.getEsmExportName = y;
  function _(m) {
    return new n(m.toString());
  }
  e.regexpCode = _;
})(nr);
var mn = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
  const t = nr;
  class r extends Error {
    constructor(i) {
      super(`CodeGen: "code" for ${i} not defined`), this.value = i.value;
    }
  }
  var n;
  (function(f) {
    f[f.Started = 0] = "Started", f[f.Completed = 1] = "Completed";
  })(n = e.UsedValueState || (e.UsedValueState = {})), e.varKinds = {
    const: new t.Name("const"),
    let: new t.Name("let"),
    var: new t.Name("var")
  };
  class s {
    constructor({ prefixes: i, parent: u } = {}) {
      this._names = {}, this._prefixes = i, this._parent = u;
    }
    toName(i) {
      return i instanceof t.Name ? i : this.name(i);
    }
    name(i) {
      return new t.Name(this._newName(i));
    }
    _newName(i) {
      const u = this._names[i] || this._nameGroup(i);
      return `${i}${u.index++}`;
    }
    _nameGroup(i) {
      var u, l;
      if (!((l = (u = this._parent) === null || u === void 0 ? void 0 : u._prefixes) === null || l === void 0) && l.has(i) || this._prefixes && !this._prefixes.has(i))
        throw new Error(`CodeGen: prefix "${i}" is not allowed in this scope`);
      return this._names[i] = { prefix: i, index: 0 };
    }
  }
  e.Scope = s;
  class o extends t.Name {
    constructor(i, u) {
      super(u), this.prefix = i;
    }
    setValue(i, { property: u, itemIndex: l }) {
      this.value = i, this.scopePath = (0, t._)`.${new t.Name(u)}[${l}]`;
    }
  }
  e.ValueScopeName = o;
  const a = (0, t._)`\n`;
  class c extends s {
    constructor(i) {
      super(i), this._values = {}, this._scope = i.scope, this.opts = { ...i, _n: i.lines ? a : t.nil };
    }
    get() {
      return this._scope;
    }
    name(i) {
      return new o(i, this._newName(i));
    }
    value(i, u) {
      var l;
      if (u.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const w = this.toName(i), { prefix: b } = w, h = (l = u.key) !== null && l !== void 0 ? l : u.ref;
      let y = this._values[b];
      if (y) {
        const E = y.get(h);
        if (E)
          return E;
      } else
        y = this._values[b] = /* @__PURE__ */ new Map();
      y.set(h, w);
      const _ = this._scope[b] || (this._scope[b] = []), m = _.length;
      return _[m] = u.ref, w.setValue(u, { property: b, itemIndex: m }), w;
    }
    getValue(i, u) {
      const l = this._values[i];
      if (l)
        return l.get(u);
    }
    scopeRefs(i, u = this._values) {
      return this._reduceValues(u, (l) => {
        if (l.scopePath === void 0)
          throw new Error(`CodeGen: name "${l}" has no value`);
        return (0, t._)`${i}${l.scopePath}`;
      });
    }
    scopeCode(i = this._values, u, l) {
      return this._reduceValues(i, (w) => {
        if (w.value === void 0)
          throw new Error(`CodeGen: name "${w}" has no value`);
        return w.value.code;
      }, u, l);
    }
    _reduceValues(i, u, l = {}, w) {
      let b = t.nil;
      for (const h in i) {
        const y = i[h];
        if (!y)
          continue;
        const _ = l[h] = l[h] || /* @__PURE__ */ new Map();
        y.forEach((m) => {
          if (_.has(m))
            return;
          _.set(m, n.Started);
          let E = u(m);
          if (E) {
            const O = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
            b = (0, t._)`${b}${O} ${m} = ${E};${this.opts._n}`;
          } else if (E = w == null ? void 0 : w(m))
            b = (0, t._)`${b}${E}${this.opts._n}`;
          else
            throw new r(m);
          _.set(m, n.Completed);
        });
      }
      return b;
    }
  }
  e.ValueScope = c;
})(mn);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
  const t = nr, r = mn;
  var n = nr;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return n._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return n.str;
  } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
    return n.strConcat;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return n.nil;
  } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
    return n.getProperty;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return n.stringify;
  } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
    return n.regexpCode;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return n.Name;
  } });
  var s = mn;
  Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
    return s.Scope;
  } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
    return s.ValueScope;
  } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
    return s.ValueScopeName;
  } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
    return s.varKinds;
  } }), e.operators = {
    GT: new t._Code(">"),
    GTE: new t._Code(">="),
    LT: new t._Code("<"),
    LTE: new t._Code("<="),
    EQ: new t._Code("==="),
    NEQ: new t._Code("!=="),
    NOT: new t._Code("!"),
    OR: new t._Code("||"),
    AND: new t._Code("&&"),
    ADD: new t._Code("+")
  };
  class o {
    optimizeNodes() {
      return this;
    }
    optimizeNames(d, v) {
      return this;
    }
  }
  class a extends o {
    constructor(d, v, A) {
      super(), this.varKind = d, this.name = v, this.rhs = A;
    }
    render({ es5: d, _n: v }) {
      const A = d ? r.varKinds.var : this.varKind, z = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${A} ${this.name}${z};` + v;
    }
    optimizeNames(d, v) {
      if (d[this.name.str])
        return this.rhs && (this.rhs = se(this.rhs, d, v)), this;
    }
    get names() {
      return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
    }
  }
  class c extends o {
    constructor(d, v, A) {
      super(), this.lhs = d, this.rhs = v, this.sideEffects = A;
    }
    render({ _n: d }) {
      return `${this.lhs} = ${this.rhs};` + d;
    }
    optimizeNames(d, v) {
      if (!(this.lhs instanceof t.Name && !d[this.lhs.str] && !this.sideEffects))
        return this.rhs = se(this.rhs, d, v), this;
    }
    get names() {
      const d = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
      return pe(d, this.rhs);
    }
  }
  class f extends c {
    constructor(d, v, A, z) {
      super(d, A, z), this.op = v;
    }
    render({ _n: d }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + d;
    }
  }
  class i extends o {
    constructor(d) {
      super(), this.label = d, this.names = {};
    }
    render({ _n: d }) {
      return `${this.label}:` + d;
    }
  }
  class u extends o {
    constructor(d) {
      super(), this.label = d, this.names = {};
    }
    render({ _n: d }) {
      return `break${this.label ? ` ${this.label}` : ""};` + d;
    }
  }
  class l extends o {
    constructor(d) {
      super(), this.error = d;
    }
    render({ _n: d }) {
      return `throw ${this.error};` + d;
    }
    get names() {
      return this.error.names;
    }
  }
  class w extends o {
    constructor(d) {
      super(), this.code = d;
    }
    render({ _n: d }) {
      return `${this.code};` + d;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(d, v) {
      return this.code = se(this.code, d, v), this;
    }
    get names() {
      return this.code instanceof t._CodeOrName ? this.code.names : {};
    }
  }
  class b extends o {
    constructor(d = []) {
      super(), this.nodes = d;
    }
    render(d) {
      return this.nodes.reduce((v, A) => v + A.render(d), "");
    }
    optimizeNodes() {
      const { nodes: d } = this;
      let v = d.length;
      for (; v--; ) {
        const A = d[v].optimizeNodes();
        Array.isArray(A) ? d.splice(v, 1, ...A) : A ? d[v] = A : d.splice(v, 1);
      }
      return d.length > 0 ? this : void 0;
    }
    optimizeNames(d, v) {
      const { nodes: A } = this;
      let z = A.length;
      for (; z--; ) {
        const V = A[z];
        V.optimizeNames(d, v) || (Oe(d, V.names), A.splice(z, 1));
      }
      return A.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((d, v) => B(d, v.names), {});
    }
  }
  class h extends b {
    render(d) {
      return "{" + d._n + super.render(d) + "}" + d._n;
    }
  }
  class y extends b {
  }
  class _ extends h {
  }
  _.kind = "else";
  class m extends h {
    constructor(d, v) {
      super(v), this.condition = d;
    }
    render(d) {
      let v = `if(${this.condition})` + super.render(d);
      return this.else && (v += "else " + this.else.render(d)), v;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const d = this.condition;
      if (d === !0)
        return this.nodes;
      let v = this.else;
      if (v) {
        const A = v.optimizeNodes();
        v = this.else = Array.isArray(A) ? new _(A) : A;
      }
      if (v)
        return d === !1 ? v instanceof m ? v : v.nodes : this.nodes.length ? this : new m(ot(d), v instanceof m ? [v] : v.nodes);
      if (!(d === !1 || !this.nodes.length))
        return this;
    }
    optimizeNames(d, v) {
      var A;
      if (this.else = (A = this.else) === null || A === void 0 ? void 0 : A.optimizeNames(d, v), !!(super.optimizeNames(d, v) || this.else))
        return this.condition = se(this.condition, d, v), this;
    }
    get names() {
      const d = super.names;
      return pe(d, this.condition), this.else && B(d, this.else.names), d;
    }
  }
  m.kind = "if";
  class E extends h {
  }
  E.kind = "for";
  class O extends E {
    constructor(d) {
      super(), this.iteration = d;
    }
    render(d) {
      return `for(${this.iteration})` + super.render(d);
    }
    optimizeNames(d, v) {
      if (super.optimizeNames(d, v))
        return this.iteration = se(this.iteration, d, v), this;
    }
    get names() {
      return B(super.names, this.iteration.names);
    }
  }
  class j extends E {
    constructor(d, v, A, z) {
      super(), this.varKind = d, this.name = v, this.from = A, this.to = z;
    }
    render(d) {
      const v = d.es5 ? r.varKinds.var : this.varKind, { name: A, from: z, to: V } = this;
      return `for(${v} ${A}=${z}; ${A}<${V}; ${A}++)` + super.render(d);
    }
    get names() {
      const d = pe(super.names, this.from);
      return pe(d, this.to);
    }
  }
  class k extends E {
    constructor(d, v, A, z) {
      super(), this.loop = d, this.varKind = v, this.name = A, this.iterable = z;
    }
    render(d) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(d);
    }
    optimizeNames(d, v) {
      if (super.optimizeNames(d, v))
        return this.iterable = se(this.iterable, d, v), this;
    }
    get names() {
      return B(super.names, this.iterable.names);
    }
  }
  class S extends h {
    constructor(d, v, A) {
      super(), this.name = d, this.args = v, this.async = A;
    }
    render(d) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(d);
    }
  }
  S.kind = "func";
  class C extends b {
    render(d) {
      return "return " + super.render(d);
    }
  }
  C.kind = "return";
  class M extends h {
    render(d) {
      let v = "try" + super.render(d);
      return this.catch && (v += this.catch.render(d)), this.finally && (v += this.finally.render(d)), v;
    }
    optimizeNodes() {
      var d, v;
      return super.optimizeNodes(), (d = this.catch) === null || d === void 0 || d.optimizeNodes(), (v = this.finally) === null || v === void 0 || v.optimizeNodes(), this;
    }
    optimizeNames(d, v) {
      var A, z;
      return super.optimizeNames(d, v), (A = this.catch) === null || A === void 0 || A.optimizeNames(d, v), (z = this.finally) === null || z === void 0 || z.optimizeNames(d, v), this;
    }
    get names() {
      const d = super.names;
      return this.catch && B(d, this.catch.names), this.finally && B(d, this.finally.names), d;
    }
  }
  class F extends h {
    constructor(d) {
      super(), this.error = d;
    }
    render(d) {
      return `catch(${this.error})` + super.render(d);
    }
  }
  F.kind = "catch";
  class L extends h {
    render(d) {
      return "finally" + super.render(d);
    }
  }
  L.kind = "finally";
  class x {
    constructor(d, v = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...v, _n: v.lines ? `
` : "" }, this._extScope = d, this._scope = new r.Scope({ parent: d }), this._nodes = [new y()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(d) {
      return this._scope.name(d);
    }
    // reserves unique name in the external scope
    scopeName(d) {
      return this._extScope.name(d);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(d, v) {
      const A = this._extScope.value(d, v);
      return (this._values[A.prefix] || (this._values[A.prefix] = /* @__PURE__ */ new Set())).add(A), A;
    }
    getScopeValue(d, v) {
      return this._extScope.getValue(d, v);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(d) {
      return this._extScope.scopeRefs(d, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(d, v, A, z) {
      const V = this._scope.toName(v);
      return A !== void 0 && z && (this._constants[V.str] = A), this._leafNode(new a(d, V, A)), V;
    }
    // `const` declaration (`var` in es5 mode)
    const(d, v, A) {
      return this._def(r.varKinds.const, d, v, A);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(d, v, A) {
      return this._def(r.varKinds.let, d, v, A);
    }
    // `var` declaration with optional assignment
    var(d, v, A) {
      return this._def(r.varKinds.var, d, v, A);
    }
    // assignment code
    assign(d, v, A) {
      return this._leafNode(new c(d, v, A));
    }
    // `+=` code
    add(d, v) {
      return this._leafNode(new f(d, e.operators.ADD, v));
    }
    // appends passed SafeExpr to code or executes Block
    code(d) {
      return typeof d == "function" ? d() : d !== t.nil && this._leafNode(new w(d)), this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...d) {
      const v = ["{"];
      for (const [A, z] of d)
        v.length > 1 && v.push(","), v.push(A), (A !== z || this.opts.es5) && (v.push(":"), (0, t.addCodeArg)(v, z));
      return v.push("}"), new t._Code(v);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(d, v, A) {
      if (this._blockNode(new m(d)), v && A)
        this.code(v).else().code(A).endIf();
      else if (v)
        this.code(v).endIf();
      else if (A)
        throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(d) {
      return this._elseNode(new m(d));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new _());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(m, _);
    }
    _for(d, v) {
      return this._blockNode(d), v && this.code(v).endFor(), this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(d, v) {
      return this._for(new O(d), v);
    }
    // `for` statement for a range of values
    forRange(d, v, A, z, V = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
      const Y = this._scope.toName(d);
      return this._for(new j(V, Y, v, A), () => z(Y));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(d, v, A, z = r.varKinds.const) {
      const V = this._scope.toName(d);
      if (this.opts.es5) {
        const Y = v instanceof t.Name ? v : this.var("_arr", v);
        return this.forRange("_i", 0, (0, t._)`${Y}.length`, (Z) => {
          this.var(V, (0, t._)`${Y}[${Z}]`), A(V);
        });
      }
      return this._for(new k("of", z, V, v), () => A(V));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(d, v, A, z = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf(d, (0, t._)`Object.keys(${v})`, A);
      const V = this._scope.toName(d);
      return this._for(new k("in", z, V, v), () => A(V));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(E);
    }
    // `label` statement
    label(d) {
      return this._leafNode(new i(d));
    }
    // `break` statement
    break(d) {
      return this._leafNode(new u(d));
    }
    // `return` statement
    return(d) {
      const v = new C();
      if (this._blockNode(v), this.code(d), v.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(C);
    }
    // `try` statement
    try(d, v, A) {
      if (!v && !A)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const z = new M();
      if (this._blockNode(z), this.code(d), v) {
        const V = this.name("e");
        this._currNode = z.catch = new F(V), v(V);
      }
      return A && (this._currNode = z.finally = new L(), this.code(A)), this._endBlockNode(F, L);
    }
    // `throw` statement
    throw(d) {
      return this._leafNode(new l(d));
    }
    // start self-balancing block
    block(d, v) {
      return this._blockStarts.push(this._nodes.length), d && this.code(d).endBlock(v), this;
    }
    // end the current self-balancing block
    endBlock(d) {
      const v = this._blockStarts.pop();
      if (v === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const A = this._nodes.length - v;
      if (A < 0 || d !== void 0 && A !== d)
        throw new Error(`CodeGen: wrong number of nodes: ${A} vs ${d} expected`);
      return this._nodes.length = v, this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(d, v = t.nil, A, z) {
      return this._blockNode(new S(d, v, A)), z && this.code(z).endFunc(), this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(S);
    }
    optimize(d = 1) {
      for (; d-- > 0; )
        this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(d) {
      return this._currNode.nodes.push(d), this;
    }
    _blockNode(d) {
      this._currNode.nodes.push(d), this._nodes.push(d);
    }
    _endBlockNode(d, v) {
      const A = this._currNode;
      if (A instanceof d || v && A instanceof v)
        return this._nodes.pop(), this;
      throw new Error(`CodeGen: not in block "${v ? `${d.kind}/${v.kind}` : d.kind}"`);
    }
    _elseNode(d) {
      const v = this._currNode;
      if (!(v instanceof m))
        throw new Error('CodeGen: "else" without "if"');
      return this._currNode = v.else = d, this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const d = this._nodes;
      return d[d.length - 1];
    }
    set _currNode(d) {
      const v = this._nodes;
      v[v.length - 1] = d;
    }
  }
  e.CodeGen = x;
  function B(N, d) {
    for (const v in d)
      N[v] = (N[v] || 0) + (d[v] || 0);
    return N;
  }
  function pe(N, d) {
    return d instanceof t._CodeOrName ? B(N, d.names) : N;
  }
  function se(N, d, v) {
    if (N instanceof t.Name)
      return A(N);
    if (!z(N))
      return N;
    return new t._Code(N._items.reduce((V, Y) => (Y instanceof t.Name && (Y = A(Y)), Y instanceof t._Code ? V.push(...Y._items) : V.push(Y), V), []));
    function A(V) {
      const Y = v[V.str];
      return Y === void 0 || d[V.str] !== 1 ? V : (delete d[V.str], Y);
    }
    function z(V) {
      return V instanceof t._Code && V._items.some((Y) => Y instanceof t.Name && d[Y.str] === 1 && v[Y.str] !== void 0);
    }
  }
  function Oe(N, d) {
    for (const v in d)
      N[v] = (N[v] || 0) - (d[v] || 0);
  }
  function ot(N) {
    return typeof N == "boolean" || typeof N == "number" || N === null ? !N : (0, t._)`!${D(N)}`;
  }
  e.not = ot;
  const yt = P(e.operators.AND);
  function Mt(...N) {
    return N.reduce(yt);
  }
  e.and = Mt;
  const gt = P(e.operators.OR);
  function U(...N) {
    return N.reduce(gt);
  }
  e.or = U;
  function P(N) {
    return (d, v) => d === t.nil ? v : v === t.nil ? d : (0, t._)`${D(d)} ${N} ${D(v)}`;
  }
  function D(N) {
    return N instanceof t.Name ? N : (0, t._)`(${N})`;
  }
})(W);
var re = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.checkStrictMode = e.getErrorPath = e.Type = e.useFunc = e.setEvaluated = e.evaluatedPropsToName = e.mergeEvaluated = e.eachItem = e.unescapeJsonPointer = e.escapeJsonPointer = e.escapeFragment = e.unescapeFragment = e.schemaRefOrVal = e.schemaHasRulesButRef = e.schemaHasRules = e.checkUnknownRules = e.alwaysValidSchema = e.toHash = void 0;
  const t = W, r = nr;
  function n(S) {
    const C = {};
    for (const M of S)
      C[M] = !0;
    return C;
  }
  e.toHash = n;
  function s(S, C) {
    return typeof C == "boolean" ? C : Object.keys(C).length === 0 ? !0 : (o(S, C), !a(C, S.self.RULES.all));
  }
  e.alwaysValidSchema = s;
  function o(S, C = S.schema) {
    const { opts: M, self: F } = S;
    if (!M.strictSchema || typeof C == "boolean")
      return;
    const L = F.RULES.keywords;
    for (const x in C)
      L[x] || k(S, `unknown keyword: "${x}"`);
  }
  e.checkUnknownRules = o;
  function a(S, C) {
    if (typeof S == "boolean")
      return !S;
    for (const M in S)
      if (C[M])
        return !0;
    return !1;
  }
  e.schemaHasRules = a;
  function c(S, C) {
    if (typeof S == "boolean")
      return !S;
    for (const M in S)
      if (M !== "$ref" && C.all[M])
        return !0;
    return !1;
  }
  e.schemaHasRulesButRef = c;
  function f({ topSchemaRef: S, schemaPath: C }, M, F, L) {
    if (!L) {
      if (typeof M == "number" || typeof M == "boolean")
        return M;
      if (typeof M == "string")
        return (0, t._)`${M}`;
    }
    return (0, t._)`${S}${C}${(0, t.getProperty)(F)}`;
  }
  e.schemaRefOrVal = f;
  function i(S) {
    return w(decodeURIComponent(S));
  }
  e.unescapeFragment = i;
  function u(S) {
    return encodeURIComponent(l(S));
  }
  e.escapeFragment = u;
  function l(S) {
    return typeof S == "number" ? `${S}` : S.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  e.escapeJsonPointer = l;
  function w(S) {
    return S.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  e.unescapeJsonPointer = w;
  function b(S, C) {
    if (Array.isArray(S))
      for (const M of S)
        C(M);
    else
      C(S);
  }
  e.eachItem = b;
  function h({ mergeNames: S, mergeToName: C, mergeValues: M, resultToName: F }) {
    return (L, x, B, pe) => {
      const se = B === void 0 ? x : B instanceof t.Name ? (x instanceof t.Name ? S(L, x, B) : C(L, x, B), B) : x instanceof t.Name ? (C(L, B, x), x) : M(x, B);
      return pe === t.Name && !(se instanceof t.Name) ? F(L, se) : se;
    };
  }
  e.mergeEvaluated = {
    props: h({
      mergeNames: (S, C, M) => S.if((0, t._)`${M} !== true && ${C} !== undefined`, () => {
        S.if((0, t._)`${C} === true`, () => S.assign(M, !0), () => S.assign(M, (0, t._)`${M} || {}`).code((0, t._)`Object.assign(${M}, ${C})`));
      }),
      mergeToName: (S, C, M) => S.if((0, t._)`${M} !== true`, () => {
        C === !0 ? S.assign(M, !0) : (S.assign(M, (0, t._)`${M} || {}`), _(S, M, C));
      }),
      mergeValues: (S, C) => S === !0 ? !0 : { ...S, ...C },
      resultToName: y
    }),
    items: h({
      mergeNames: (S, C, M) => S.if((0, t._)`${M} !== true && ${C} !== undefined`, () => S.assign(M, (0, t._)`${C} === true ? true : ${M} > ${C} ? ${M} : ${C}`)),
      mergeToName: (S, C, M) => S.if((0, t._)`${M} !== true`, () => S.assign(M, C === !0 ? !0 : (0, t._)`${M} > ${C} ? ${M} : ${C}`)),
      mergeValues: (S, C) => S === !0 ? !0 : Math.max(S, C),
      resultToName: (S, C) => S.var("items", C)
    })
  };
  function y(S, C) {
    if (C === !0)
      return S.var("props", !0);
    const M = S.var("props", (0, t._)`{}`);
    return C !== void 0 && _(S, M, C), M;
  }
  e.evaluatedPropsToName = y;
  function _(S, C, M) {
    Object.keys(M).forEach((F) => S.assign((0, t._)`${C}${(0, t.getProperty)(F)}`, !0));
  }
  e.setEvaluated = _;
  const m = {};
  function E(S, C) {
    return S.scopeValue("func", {
      ref: C,
      code: m[C.code] || (m[C.code] = new r._Code(C.code))
    });
  }
  e.useFunc = E;
  var O;
  (function(S) {
    S[S.Num = 0] = "Num", S[S.Str = 1] = "Str";
  })(O = e.Type || (e.Type = {}));
  function j(S, C, M) {
    if (S instanceof t.Name) {
      const F = C === O.Num;
      return M ? F ? (0, t._)`"[" + ${S} + "]"` : (0, t._)`"['" + ${S} + "']"` : F ? (0, t._)`"/" + ${S}` : (0, t._)`"/" + ${S}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return M ? (0, t.getProperty)(S).toString() : "/" + l(S);
  }
  e.getErrorPath = j;
  function k(S, C, M = S.opts.strictSchema) {
    if (M) {
      if (C = `strict mode: ${C}`, M === !0)
        throw new Error(C);
      S.self.logger.warn(C);
    }
  }
  e.checkStrictMode = k;
})(re);
var Be = {};
Object.defineProperty(Be, "__esModule", { value: !0 });
const $e = W, Wa = {
  // validation function arguments
  data: new $e.Name("data"),
  // args passed from referencing schema
  valCxt: new $e.Name("valCxt"),
  instancePath: new $e.Name("instancePath"),
  parentData: new $e.Name("parentData"),
  parentDataProperty: new $e.Name("parentDataProperty"),
  rootData: new $e.Name("rootData"),
  dynamicAnchors: new $e.Name("dynamicAnchors"),
  // function scoped variables
  vErrors: new $e.Name("vErrors"),
  errors: new $e.Name("errors"),
  this: new $e.Name("this"),
  // "globals"
  self: new $e.Name("self"),
  scope: new $e.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new $e.Name("json"),
  jsonPos: new $e.Name("jsonPos"),
  jsonLen: new $e.Name("jsonLen"),
  jsonPart: new $e.Name("jsonPart")
};
Be.default = Wa;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
  const t = W, r = re, n = Be;
  e.keywordError = {
    message: ({ keyword: _ }) => (0, t.str)`must pass "${_}" keyword validation`
  }, e.keyword$DataError = {
    message: ({ keyword: _, schemaType: m }) => m ? (0, t.str)`"${_}" keyword must be ${m} ($data)` : (0, t.str)`"${_}" keyword is invalid ($data)`
  };
  function s(_, m = e.keywordError, E, O) {
    const { it: j } = _, { gen: k, compositeRule: S, allErrors: C } = j, M = l(_, m, E);
    O ?? (S || C) ? f(k, M) : i(j, (0, t._)`[${M}]`);
  }
  e.reportError = s;
  function o(_, m = e.keywordError, E) {
    const { it: O } = _, { gen: j, compositeRule: k, allErrors: S } = O, C = l(_, m, E);
    f(j, C), k || S || i(O, n.default.vErrors);
  }
  e.reportExtraError = o;
  function a(_, m) {
    _.assign(n.default.errors, m), _.if((0, t._)`${n.default.vErrors} !== null`, () => _.if(m, () => _.assign((0, t._)`${n.default.vErrors}.length`, m), () => _.assign(n.default.vErrors, null)));
  }
  e.resetErrorsCount = a;
  function c({ gen: _, keyword: m, schemaValue: E, data: O, errsCount: j, it: k }) {
    if (j === void 0)
      throw new Error("ajv implementation error");
    const S = _.name("err");
    _.forRange("i", j, n.default.errors, (C) => {
      _.const(S, (0, t._)`${n.default.vErrors}[${C}]`), _.if((0, t._)`${S}.instancePath === undefined`, () => _.assign((0, t._)`${S}.instancePath`, (0, t.strConcat)(n.default.instancePath, k.errorPath))), _.assign((0, t._)`${S}.schemaPath`, (0, t.str)`${k.errSchemaPath}/${m}`), k.opts.verbose && (_.assign((0, t._)`${S}.schema`, E), _.assign((0, t._)`${S}.data`, O));
    });
  }
  e.extendErrors = c;
  function f(_, m) {
    const E = _.const("err", m);
    _.if((0, t._)`${n.default.vErrors} === null`, () => _.assign(n.default.vErrors, (0, t._)`[${E}]`), (0, t._)`${n.default.vErrors}.push(${E})`), _.code((0, t._)`${n.default.errors}++`);
  }
  function i(_, m) {
    const { gen: E, validateName: O, schemaEnv: j } = _;
    j.$async ? E.throw((0, t._)`new ${_.ValidationError}(${m})`) : (E.assign((0, t._)`${O}.errors`, m), E.return(!1));
  }
  const u = {
    keyword: new t.Name("keyword"),
    schemaPath: new t.Name("schemaPath"),
    params: new t.Name("params"),
    propertyName: new t.Name("propertyName"),
    message: new t.Name("message"),
    schema: new t.Name("schema"),
    parentSchema: new t.Name("parentSchema")
  };
  function l(_, m, E) {
    const { createErrors: O } = _.it;
    return O === !1 ? (0, t._)`{}` : w(_, m, E);
  }
  function w(_, m, E = {}) {
    const { gen: O, it: j } = _, k = [
      b(j, E),
      h(_, E)
    ];
    return y(_, m, k), O.object(...k);
  }
  function b({ errorPath: _ }, { instancePath: m }) {
    const E = m ? (0, t.str)`${_}${(0, r.getErrorPath)(m, r.Type.Str)}` : _;
    return [n.default.instancePath, (0, t.strConcat)(n.default.instancePath, E)];
  }
  function h({ keyword: _, it: { errSchemaPath: m } }, { schemaPath: E, parentSchema: O }) {
    let j = O ? m : (0, t.str)`${m}/${_}`;
    return E && (j = (0, t.str)`${j}${(0, r.getErrorPath)(E, r.Type.Str)}`), [u.schemaPath, j];
  }
  function y(_, { params: m, message: E }, O) {
    const { keyword: j, data: k, schemaValue: S, it: C } = _, { opts: M, propertyName: F, topSchemaRef: L, schemaPath: x } = C;
    O.push([u.keyword, j], [u.params, typeof m == "function" ? m(_) : m || (0, t._)`{}`]), M.messages && O.push([u.message, typeof E == "function" ? E(_) : E]), M.verbose && O.push([u.schema, S], [u.parentSchema, (0, t._)`${L}${x}`], [n.default.data, k]), F && O.push([u.propertyName, F]);
  }
})(ir);
Object.defineProperty(Ct, "__esModule", { value: !0 });
Ct.boolOrEmptySchema = Ct.topBoolOrEmptySchema = void 0;
const xa = ir, Xa = W, Ya = Be, Qa = {
  message: "boolean schema is false"
};
function Za(e) {
  const { gen: t, schema: r, validateName: n } = e;
  r === !1 ? yo(e, !1) : typeof r == "object" && r.$async === !0 ? t.return(Ya.default.data) : (t.assign((0, Xa._)`${n}.errors`, null), t.return(!0));
}
Ct.topBoolOrEmptySchema = Za;
function ei(e, t) {
  const { gen: r, schema: n } = e;
  n === !1 ? (r.var(t, !1), yo(e)) : r.var(t, !0);
}
Ct.boolOrEmptySchema = ei;
function yo(e, t) {
  const { gen: r, data: n } = e, s = {
    gen: r,
    keyword: "false schema",
    data: n,
    schema: !1,
    schemaCode: !1,
    schemaValue: !1,
    params: {},
    it: e
  };
  (0, xa.reportError)(s, Qa, void 0, t);
}
var cr = {}, ht = {};
Object.defineProperty(ht, "__esModule", { value: !0 });
ht.getRules = ht.isJSONType = void 0;
const ti = ["string", "number", "integer", "boolean", "null", "object", "array"], ri = new Set(ti);
function ni(e) {
  return typeof e == "string" && ri.has(e);
}
ht.isJSONType = ni;
function si() {
  const e = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...e, integer: !0, boolean: !0, null: !0 },
    rules: [{ rules: [] }, e.number, e.string, e.array, e.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
ht.getRules = si;
var We = {};
Object.defineProperty(We, "__esModule", { value: !0 });
We.shouldUseRule = We.shouldUseGroup = We.schemaHasRulesForType = void 0;
function oi({ schema: e, self: t }, r) {
  const n = t.RULES.types[r];
  return n && n !== !0 && go(e, n);
}
We.schemaHasRulesForType = oi;
function go(e, t) {
  return t.rules.some((r) => vo(e, r));
}
We.shouldUseGroup = go;
function vo(e, t) {
  var r;
  return e[t.keyword] !== void 0 || ((r = t.definition.implements) === null || r === void 0 ? void 0 : r.some((n) => e[n] !== void 0));
}
We.shouldUseRule = vo;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.reportTypeError = e.checkDataTypes = e.checkDataType = e.coerceAndCheckDataType = e.getJSONTypes = e.getSchemaTypes = e.DataType = void 0;
  const t = ht, r = We, n = ir, s = W, o = re;
  var a;
  (function(O) {
    O[O.Correct = 0] = "Correct", O[O.Wrong = 1] = "Wrong";
  })(a = e.DataType || (e.DataType = {}));
  function c(O) {
    const j = f(O.type);
    if (j.includes("null")) {
      if (O.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!j.length && O.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      O.nullable === !0 && j.push("null");
    }
    return j;
  }
  e.getSchemaTypes = c;
  function f(O) {
    const j = Array.isArray(O) ? O : O ? [O] : [];
    if (j.every(t.isJSONType))
      return j;
    throw new Error("type must be JSONType or JSONType[]: " + j.join(","));
  }
  e.getJSONTypes = f;
  function i(O, j) {
    const { gen: k, data: S, opts: C } = O, M = l(j, C.coerceTypes), F = j.length > 0 && !(M.length === 0 && j.length === 1 && (0, r.schemaHasRulesForType)(O, j[0]));
    if (F) {
      const L = y(j, S, C.strictNumbers, a.Wrong);
      k.if(L, () => {
        M.length ? w(O, j, M) : m(O);
      });
    }
    return F;
  }
  e.coerceAndCheckDataType = i;
  const u = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function l(O, j) {
    return j ? O.filter((k) => u.has(k) || j === "array" && k === "array") : [];
  }
  function w(O, j, k) {
    const { gen: S, data: C, opts: M } = O, F = S.let("dataType", (0, s._)`typeof ${C}`), L = S.let("coerced", (0, s._)`undefined`);
    M.coerceTypes === "array" && S.if((0, s._)`${F} == 'object' && Array.isArray(${C}) && ${C}.length == 1`, () => S.assign(C, (0, s._)`${C}[0]`).assign(F, (0, s._)`typeof ${C}`).if(y(j, C, M.strictNumbers), () => S.assign(L, C))), S.if((0, s._)`${L} !== undefined`);
    for (const B of k)
      (u.has(B) || B === "array" && M.coerceTypes === "array") && x(B);
    S.else(), m(O), S.endIf(), S.if((0, s._)`${L} !== undefined`, () => {
      S.assign(C, L), b(O, L);
    });
    function x(B) {
      switch (B) {
        case "string":
          S.elseIf((0, s._)`${F} == "number" || ${F} == "boolean"`).assign(L, (0, s._)`"" + ${C}`).elseIf((0, s._)`${C} === null`).assign(L, (0, s._)`""`);
          return;
        case "number":
          S.elseIf((0, s._)`${F} == "boolean" || ${C} === null
              || (${F} == "string" && ${C} && ${C} == +${C})`).assign(L, (0, s._)`+${C}`);
          return;
        case "integer":
          S.elseIf((0, s._)`${F} === "boolean" || ${C} === null
              || (${F} === "string" && ${C} && ${C} == +${C} && !(${C} % 1))`).assign(L, (0, s._)`+${C}`);
          return;
        case "boolean":
          S.elseIf((0, s._)`${C} === "false" || ${C} === 0 || ${C} === null`).assign(L, !1).elseIf((0, s._)`${C} === "true" || ${C} === 1`).assign(L, !0);
          return;
        case "null":
          S.elseIf((0, s._)`${C} === "" || ${C} === 0 || ${C} === false`), S.assign(L, null);
          return;
        case "array":
          S.elseIf((0, s._)`${F} === "string" || ${F} === "number"
              || ${F} === "boolean" || ${C} === null`).assign(L, (0, s._)`[${C}]`);
      }
    }
  }
  function b({ gen: O, parentData: j, parentDataProperty: k }, S) {
    O.if((0, s._)`${j} !== undefined`, () => O.assign((0, s._)`${j}[${k}]`, S));
  }
  function h(O, j, k, S = a.Correct) {
    const C = S === a.Correct ? s.operators.EQ : s.operators.NEQ;
    let M;
    switch (O) {
      case "null":
        return (0, s._)`${j} ${C} null`;
      case "array":
        M = (0, s._)`Array.isArray(${j})`;
        break;
      case "object":
        M = (0, s._)`${j} && typeof ${j} == "object" && !Array.isArray(${j})`;
        break;
      case "integer":
        M = F((0, s._)`!(${j} % 1) && !isNaN(${j})`);
        break;
      case "number":
        M = F();
        break;
      default:
        return (0, s._)`typeof ${j} ${C} ${O}`;
    }
    return S === a.Correct ? M : (0, s.not)(M);
    function F(L = s.nil) {
      return (0, s.and)((0, s._)`typeof ${j} == "number"`, L, k ? (0, s._)`isFinite(${j})` : s.nil);
    }
  }
  e.checkDataType = h;
  function y(O, j, k, S) {
    if (O.length === 1)
      return h(O[0], j, k, S);
    let C;
    const M = (0, o.toHash)(O);
    if (M.array && M.object) {
      const F = (0, s._)`typeof ${j} != "object"`;
      C = M.null ? F : (0, s._)`!${j} || ${F}`, delete M.null, delete M.array, delete M.object;
    } else
      C = s.nil;
    M.number && delete M.integer;
    for (const F in M)
      C = (0, s.and)(C, h(F, j, k, S));
    return C;
  }
  e.checkDataTypes = y;
  const _ = {
    message: ({ schema: O }) => `must be ${O}`,
    params: ({ schema: O, schemaValue: j }) => typeof O == "string" ? (0, s._)`{type: ${O}}` : (0, s._)`{type: ${j}}`
  };
  function m(O) {
    const j = E(O);
    (0, n.reportError)(j, _);
  }
  e.reportTypeError = m;
  function E(O) {
    const { gen: j, data: k, schema: S } = O, C = (0, o.schemaRefOrVal)(O, S, "type");
    return {
      gen: j,
      keyword: "type",
      data: k,
      schema: S.type,
      schemaCode: C,
      schemaValue: C,
      parentSchema: S,
      params: {},
      it: O
    };
  }
})(cr);
var Kr = {};
Object.defineProperty(Kr, "__esModule", { value: !0 });
Kr.assignDefaults = void 0;
const Pt = W, ai = re;
function ii(e, t) {
  const { properties: r, items: n } = e.schema;
  if (t === "object" && r)
    for (const s in r)
      Rs(e, s, r[s].default);
  else
    t === "array" && Array.isArray(n) && n.forEach((s, o) => Rs(e, o, s.default));
}
Kr.assignDefaults = ii;
function Rs(e, t, r) {
  const { gen: n, compositeRule: s, data: o, opts: a } = e;
  if (r === void 0)
    return;
  const c = (0, Pt._)`${o}${(0, Pt.getProperty)(t)}`;
  if (s) {
    (0, ai.checkStrictMode)(e, `default is ignored for: ${c}`);
    return;
  }
  let f = (0, Pt._)`${c} === undefined`;
  a.useDefaults === "empty" && (f = (0, Pt._)`${f} || ${c} === null || ${c} === ""`), n.if(f, (0, Pt._)`${c} = ${(0, Pt.stringify)(r)}`);
}
var He = {}, X = {};
Object.defineProperty(X, "__esModule", { value: !0 });
X.validateUnion = X.validateArray = X.usePattern = X.callValidateCode = X.schemaProperties = X.allSchemaProperties = X.noPropertyInData = X.propertyInData = X.isOwnProperty = X.hasPropFunc = X.reportMissingProp = X.checkMissingProp = X.checkReportMissingProp = void 0;
const ae = W, Nn = re, et = Be, ci = re;
function ui(e, t) {
  const { gen: r, data: n, it: s } = e;
  r.if(Rn(r, n, t, s.opts.ownProperties), () => {
    e.setParams({ missingProperty: (0, ae._)`${t}` }, !0), e.error();
  });
}
X.checkReportMissingProp = ui;
function li({ gen: e, data: t, it: { opts: r } }, n, s) {
  return (0, ae.or)(...n.map((o) => (0, ae.and)(Rn(e, t, o, r.ownProperties), (0, ae._)`${s} = ${o}`)));
}
X.checkMissingProp = li;
function di(e, t) {
  e.setParams({ missingProperty: t }, !0), e.error();
}
X.reportMissingProp = di;
function $o(e) {
  return e.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, ae._)`Object.prototype.hasOwnProperty`
  });
}
X.hasPropFunc = $o;
function Tn(e, t, r) {
  return (0, ae._)`${$o(e)}.call(${t}, ${r})`;
}
X.isOwnProperty = Tn;
function fi(e, t, r, n) {
  const s = (0, ae._)`${t}${(0, ae.getProperty)(r)} !== undefined`;
  return n ? (0, ae._)`${s} && ${Tn(e, t, r)}` : s;
}
X.propertyInData = fi;
function Rn(e, t, r, n) {
  const s = (0, ae._)`${t}${(0, ae.getProperty)(r)} === undefined`;
  return n ? (0, ae.or)(s, (0, ae.not)(Tn(e, t, r))) : s;
}
X.noPropertyInData = Rn;
function _o(e) {
  return e ? Object.keys(e).filter((t) => t !== "__proto__") : [];
}
X.allSchemaProperties = _o;
function pi(e, t) {
  return _o(t).filter((r) => !(0, Nn.alwaysValidSchema)(e, t[r]));
}
X.schemaProperties = pi;
function hi({ schemaCode: e, data: t, it: { gen: r, topSchemaRef: n, schemaPath: s, errorPath: o }, it: a }, c, f, i) {
  const u = i ? (0, ae._)`${e}, ${t}, ${n}${s}` : t, l = [
    [et.default.instancePath, (0, ae.strConcat)(et.default.instancePath, o)],
    [et.default.parentData, a.parentData],
    [et.default.parentDataProperty, a.parentDataProperty],
    [et.default.rootData, et.default.rootData]
  ];
  a.opts.dynamicRef && l.push([et.default.dynamicAnchors, et.default.dynamicAnchors]);
  const w = (0, ae._)`${u}, ${r.object(...l)}`;
  return f !== ae.nil ? (0, ae._)`${c}.call(${f}, ${w})` : (0, ae._)`${c}(${w})`;
}
X.callValidateCode = hi;
const mi = (0, ae._)`new RegExp`;
function yi({ gen: e, it: { opts: t } }, r) {
  const n = t.unicodeRegExp ? "u" : "", { regExp: s } = t.code, o = s(r, n);
  return e.scopeValue("pattern", {
    key: o.toString(),
    ref: o,
    code: (0, ae._)`${s.code === "new RegExp" ? mi : (0, ci.useFunc)(e, s)}(${r}, ${n})`
  });
}
X.usePattern = yi;
function gi(e) {
  const { gen: t, data: r, keyword: n, it: s } = e, o = t.name("valid");
  if (s.allErrors) {
    const c = t.let("valid", !0);
    return a(() => t.assign(c, !1)), c;
  }
  return t.var(o, !0), a(() => t.break()), o;
  function a(c) {
    const f = t.const("len", (0, ae._)`${r}.length`);
    t.forRange("i", 0, f, (i) => {
      e.subschema({
        keyword: n,
        dataProp: i,
        dataPropType: Nn.Type.Num
      }, o), t.if((0, ae.not)(o), c);
    });
  }
}
X.validateArray = gi;
function vi(e) {
  const { gen: t, schema: r, keyword: n, it: s } = e;
  if (!Array.isArray(r))
    throw new Error("ajv implementation error");
  if (r.some((f) => (0, Nn.alwaysValidSchema)(s, f)) && !s.opts.unevaluated)
    return;
  const a = t.let("valid", !1), c = t.name("_valid");
  t.block(() => r.forEach((f, i) => {
    const u = e.subschema({
      keyword: n,
      schemaProp: i,
      compositeRule: !0
    }, c);
    t.assign(a, (0, ae._)`${a} || ${c}`), e.mergeValidEvaluated(u, c) || t.if((0, ae.not)(a));
  })), e.result(a, () => e.reset(), () => e.error(!0));
}
X.validateUnion = vi;
Object.defineProperty(He, "__esModule", { value: !0 });
He.validateKeywordUsage = He.validSchemaType = He.funcKeywordCode = He.macroKeywordCode = void 0;
const we = W, dt = Be, $i = X, _i = ir;
function wi(e, t) {
  const { gen: r, keyword: n, schema: s, parentSchema: o, it: a } = e, c = t.macro.call(a.self, s, o, a), f = wo(r, n, c);
  a.opts.validateSchema !== !1 && a.self.validateSchema(c, !0);
  const i = r.name("valid");
  e.subschema({
    schema: c,
    schemaPath: we.nil,
    errSchemaPath: `${a.errSchemaPath}/${n}`,
    topSchemaRef: f,
    compositeRule: !0
  }, i), e.pass(i, () => e.error(!0));
}
He.macroKeywordCode = wi;
function bi(e, t) {
  var r;
  const { gen: n, keyword: s, schema: o, parentSchema: a, $data: c, it: f } = e;
  Si(f, t);
  const i = !c && t.compile ? t.compile.call(f.self, o, a, f) : t.validate, u = wo(n, s, i), l = n.let("valid");
  e.block$data(l, w), e.ok((r = t.valid) !== null && r !== void 0 ? r : l);
  function w() {
    if (t.errors === !1)
      y(), t.modifying && Cs(e), _(() => e.error());
    else {
      const m = t.async ? b() : h();
      t.modifying && Cs(e), _(() => Ei(e, m));
    }
  }
  function b() {
    const m = n.let("ruleErrs", null);
    return n.try(() => y((0, we._)`await `), (E) => n.assign(l, !1).if((0, we._)`${E} instanceof ${f.ValidationError}`, () => n.assign(m, (0, we._)`${E}.errors`), () => n.throw(E))), m;
  }
  function h() {
    const m = (0, we._)`${u}.errors`;
    return n.assign(m, null), y(we.nil), m;
  }
  function y(m = t.async ? (0, we._)`await ` : we.nil) {
    const E = f.opts.passContext ? dt.default.this : dt.default.self, O = !("compile" in t && !c || t.schema === !1);
    n.assign(l, (0, we._)`${m}${(0, $i.callValidateCode)(e, u, E, O)}`, t.modifying);
  }
  function _(m) {
    var E;
    n.if((0, we.not)((E = t.valid) !== null && E !== void 0 ? E : l), m);
  }
}
He.funcKeywordCode = bi;
function Cs(e) {
  const { gen: t, data: r, it: n } = e;
  t.if(n.parentData, () => t.assign(r, (0, we._)`${n.parentData}[${n.parentDataProperty}]`));
}
function Ei(e, t) {
  const { gen: r } = e;
  r.if((0, we._)`Array.isArray(${t})`, () => {
    r.assign(dt.default.vErrors, (0, we._)`${dt.default.vErrors} === null ? ${t} : ${dt.default.vErrors}.concat(${t})`).assign(dt.default.errors, (0, we._)`${dt.default.vErrors}.length`), (0, _i.extendErrors)(e);
  }, () => e.error());
}
function Si({ schemaEnv: e }, t) {
  if (t.async && !e.$async)
    throw new Error("async keyword in sync schema");
}
function wo(e, t, r) {
  if (r === void 0)
    throw new Error(`keyword "${t}" failed to compile`);
  return e.scopeValue("keyword", typeof r == "function" ? { ref: r } : { ref: r, code: (0, we.stringify)(r) });
}
function Pi(e, t, r = !1) {
  return !t.length || t.some((n) => n === "array" ? Array.isArray(e) : n === "object" ? e && typeof e == "object" && !Array.isArray(e) : typeof e == n || r && typeof e > "u");
}
He.validSchemaType = Pi;
function Oi({ schema: e, opts: t, self: r, errSchemaPath: n }, s, o) {
  if (Array.isArray(s.keyword) ? !s.keyword.includes(o) : s.keyword !== o)
    throw new Error("ajv implementation error");
  const a = s.dependencies;
  if (a != null && a.some((c) => !Object.prototype.hasOwnProperty.call(e, c)))
    throw new Error(`parent schema must have dependencies of ${o}: ${a.join(",")}`);
  if (s.validateSchema && !s.validateSchema(e[o])) {
    const f = `keyword "${o}" value is invalid at path "${n}": ` + r.errorsText(s.validateSchema.errors);
    if (t.validateSchema === "log")
      r.logger.error(f);
    else
      throw new Error(f);
  }
}
He.validateKeywordUsage = Oi;
var st = {};
Object.defineProperty(st, "__esModule", { value: !0 });
st.extendSubschemaMode = st.extendSubschemaData = st.getSubschema = void 0;
const Le = W, bo = re;
function Ni(e, { keyword: t, schemaProp: r, schema: n, schemaPath: s, errSchemaPath: o, topSchemaRef: a }) {
  if (t !== void 0 && n !== void 0)
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  if (t !== void 0) {
    const c = e.schema[t];
    return r === void 0 ? {
      schema: c,
      schemaPath: (0, Le._)`${e.schemaPath}${(0, Le.getProperty)(t)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}`
    } : {
      schema: c[r],
      schemaPath: (0, Le._)`${e.schemaPath}${(0, Le.getProperty)(t)}${(0, Le.getProperty)(r)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}/${(0, bo.escapeFragment)(r)}`
    };
  }
  if (n !== void 0) {
    if (s === void 0 || o === void 0 || a === void 0)
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    return {
      schema: n,
      schemaPath: s,
      topSchemaRef: a,
      errSchemaPath: o
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
st.getSubschema = Ni;
function Ti(e, t, { dataProp: r, dataPropType: n, data: s, dataTypes: o, propertyName: a }) {
  if (s !== void 0 && r !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: c } = t;
  if (r !== void 0) {
    const { errorPath: i, dataPathArr: u, opts: l } = t, w = c.let("data", (0, Le._)`${t.data}${(0, Le.getProperty)(r)}`, !0);
    f(w), e.errorPath = (0, Le.str)`${i}${(0, bo.getErrorPath)(r, n, l.jsPropertySyntax)}`, e.parentDataProperty = (0, Le._)`${r}`, e.dataPathArr = [...u, e.parentDataProperty];
  }
  if (s !== void 0) {
    const i = s instanceof Le.Name ? s : c.let("data", s, !0);
    f(i), a !== void 0 && (e.propertyName = a);
  }
  o && (e.dataTypes = o);
  function f(i) {
    e.data = i, e.dataLevel = t.dataLevel + 1, e.dataTypes = [], t.definedProperties = /* @__PURE__ */ new Set(), e.parentData = t.data, e.dataNames = [...t.dataNames, i];
  }
}
st.extendSubschemaData = Ti;
function Ri(e, { jtdDiscriminator: t, jtdMetadata: r, compositeRule: n, createErrors: s, allErrors: o }) {
  n !== void 0 && (e.compositeRule = n), s !== void 0 && (e.createErrors = s), o !== void 0 && (e.allErrors = o), e.jtdDiscriminator = t, e.jtdMetadata = r;
}
st.extendSubschemaMode = Ri;
var ve = {}, Eo = function e(t, r) {
  if (t === r)
    return !0;
  if (t && r && typeof t == "object" && typeof r == "object") {
    if (t.constructor !== r.constructor)
      return !1;
    var n, s, o;
    if (Array.isArray(t)) {
      if (n = t.length, n != r.length)
        return !1;
      for (s = n; s-- !== 0; )
        if (!e(t[s], r[s]))
          return !1;
      return !0;
    }
    if (t.constructor === RegExp)
      return t.source === r.source && t.flags === r.flags;
    if (t.valueOf !== Object.prototype.valueOf)
      return t.valueOf() === r.valueOf();
    if (t.toString !== Object.prototype.toString)
      return t.toString() === r.toString();
    if (o = Object.keys(t), n = o.length, n !== Object.keys(r).length)
      return !1;
    for (s = n; s-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, o[s]))
        return !1;
    for (s = n; s-- !== 0; ) {
      var a = o[s];
      if (!e(t[a], r[a]))
        return !1;
    }
    return !0;
  }
  return t !== t && r !== r;
}, yn = {}, Ci = {
  get exports() {
    return yn;
  },
  set exports(e) {
    yn = e;
  }
}, nt = Ci.exports = function(e, t, r) {
  typeof t == "function" && (r = t, t = {}), r = t.cb || r;
  var n = typeof r == "function" ? r : r.pre || function() {
  }, s = r.post || function() {
  };
  Er(t, n, s, e, "", e);
};
nt.keywords = {
  additionalItems: !0,
  items: !0,
  contains: !0,
  additionalProperties: !0,
  propertyNames: !0,
  not: !0,
  if: !0,
  then: !0,
  else: !0
};
nt.arrayKeywords = {
  items: !0,
  allOf: !0,
  anyOf: !0,
  oneOf: !0
};
nt.propsKeywords = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependencies: !0
};
nt.skipKeywords = {
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0
};
function Er(e, t, r, n, s, o, a, c, f, i) {
  if (n && typeof n == "object" && !Array.isArray(n)) {
    t(n, s, o, a, c, f, i);
    for (var u in n) {
      var l = n[u];
      if (Array.isArray(l)) {
        if (u in nt.arrayKeywords)
          for (var w = 0; w < l.length; w++)
            Er(e, t, r, l[w], s + "/" + u + "/" + w, o, s, u, n, w);
      } else if (u in nt.propsKeywords) {
        if (l && typeof l == "object")
          for (var b in l)
            Er(e, t, r, l[b], s + "/" + u + "/" + ji(b), o, s, u, n, b);
      } else
        (u in nt.keywords || e.allKeys && !(u in nt.skipKeywords)) && Er(e, t, r, l, s + "/" + u, o, s, u, n);
    }
    r(n, s, o, a, c, f, i);
  }
}
function ji(e) {
  return e.replace(/~/g, "~0").replace(/\//g, "~1");
}
Object.defineProperty(ve, "__esModule", { value: !0 });
ve.getSchemaRefs = ve.resolveUrl = ve.normalizeId = ve._getFullPath = ve.getFullPath = ve.inlineRef = void 0;
const Ai = re, Ii = Eo, Di = yn, ki = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function Mi(e, t = !0) {
  return typeof e == "boolean" ? !0 : t === !0 ? !gn(e) : t ? So(e) <= t : !1;
}
ve.inlineRef = Mi;
const Fi = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function gn(e) {
  for (const t in e) {
    if (Fi.has(t))
      return !0;
    const r = e[t];
    if (Array.isArray(r) && r.some(gn) || typeof r == "object" && gn(r))
      return !0;
  }
  return !1;
}
function So(e) {
  let t = 0;
  for (const r in e) {
    if (r === "$ref")
      return 1 / 0;
    if (t++, !ki.has(r) && (typeof e[r] == "object" && (0, Ai.eachItem)(e[r], (n) => t += So(n)), t === 1 / 0))
      return 1 / 0;
  }
  return t;
}
function Po(e, t = "", r) {
  r !== !1 && (t = Tt(t));
  const n = e.parse(t);
  return Oo(e, n);
}
ve.getFullPath = Po;
function Oo(e, t) {
  return e.serialize(t).split("#")[0] + "#";
}
ve._getFullPath = Oo;
const Ui = /#\/?$/;
function Tt(e) {
  return e ? e.replace(Ui, "") : "";
}
ve.normalizeId = Tt;
function zi(e, t, r) {
  return r = Tt(r), e.resolve(t, r);
}
ve.resolveUrl = zi;
const Vi = /^[a-z_][-a-z0-9._]*$/i;
function Li(e, t) {
  if (typeof e == "boolean")
    return {};
  const { schemaId: r, uriResolver: n } = this.opts, s = Tt(e[r] || t), o = { "": s }, a = Po(n, s, !1), c = {}, f = /* @__PURE__ */ new Set();
  return Di(e, { allKeys: !0 }, (l, w, b, h) => {
    if (h === void 0)
      return;
    const y = a + w;
    let _ = o[h];
    typeof l[r] == "string" && (_ = m.call(this, l[r])), E.call(this, l.$anchor), E.call(this, l.$dynamicAnchor), o[w] = _;
    function m(O) {
      const j = this.opts.uriResolver.resolve;
      if (O = Tt(_ ? j(_, O) : O), f.has(O))
        throw u(O);
      f.add(O);
      let k = this.refs[O];
      return typeof k == "string" && (k = this.refs[k]), typeof k == "object" ? i(l, k.schema, O) : O !== Tt(y) && (O[0] === "#" ? (i(l, c[O], O), c[O] = l) : this.refs[O] = y), O;
    }
    function E(O) {
      if (typeof O == "string") {
        if (!Vi.test(O))
          throw new Error(`invalid anchor "${O}"`);
        m.call(this, `#${O}`);
      }
    }
  }), c;
  function i(l, w, b) {
    if (w !== void 0 && !Ii(l, w))
      throw u(b);
  }
  function u(l) {
    return new Error(`reference "${l}" resolves to more than one schema`);
  }
}
ve.getSchemaRefs = Li;
Object.defineProperty(Ie, "__esModule", { value: !0 });
Ie.getData = Ie.KeywordCxt = Ie.validateFunctionCode = void 0;
const No = Ct, js = cr, Cn = We, Dr = cr, qi = Kr, Yt = He, tn = st, q = W, G = Be, Hi = ve, xe = re, Gt = ir;
function Ki(e) {
  if (Co(e) && (jo(e), Ro(e))) {
    Ji(e);
    return;
  }
  To(e, () => (0, No.topBoolOrEmptySchema)(e));
}
Ie.validateFunctionCode = Ki;
function To({ gen: e, validateName: t, schema: r, schemaEnv: n, opts: s }, o) {
  s.code.es5 ? e.func(t, (0, q._)`${G.default.data}, ${G.default.valCxt}`, n.$async, () => {
    e.code((0, q._)`"use strict"; ${As(r, s)}`), Gi(e, s), e.code(o);
  }) : e.func(t, (0, q._)`${G.default.data}, ${Bi(s)}`, n.$async, () => e.code(As(r, s)).code(o));
}
function Bi(e) {
  return (0, q._)`{${G.default.instancePath}="", ${G.default.parentData}, ${G.default.parentDataProperty}, ${G.default.rootData}=${G.default.data}${e.dynamicRef ? (0, q._)`, ${G.default.dynamicAnchors}={}` : q.nil}}={}`;
}
function Gi(e, t) {
  e.if(G.default.valCxt, () => {
    e.var(G.default.instancePath, (0, q._)`${G.default.valCxt}.${G.default.instancePath}`), e.var(G.default.parentData, (0, q._)`${G.default.valCxt}.${G.default.parentData}`), e.var(G.default.parentDataProperty, (0, q._)`${G.default.valCxt}.${G.default.parentDataProperty}`), e.var(G.default.rootData, (0, q._)`${G.default.valCxt}.${G.default.rootData}`), t.dynamicRef && e.var(G.default.dynamicAnchors, (0, q._)`${G.default.valCxt}.${G.default.dynamicAnchors}`);
  }, () => {
    e.var(G.default.instancePath, (0, q._)`""`), e.var(G.default.parentData, (0, q._)`undefined`), e.var(G.default.parentDataProperty, (0, q._)`undefined`), e.var(G.default.rootData, G.default.data), t.dynamicRef && e.var(G.default.dynamicAnchors, (0, q._)`{}`);
  });
}
function Ji(e) {
  const { schema: t, opts: r, gen: n } = e;
  To(e, () => {
    r.$comment && t.$comment && Io(e), Qi(e), n.let(G.default.vErrors, null), n.let(G.default.errors, 0), r.unevaluated && Wi(e), Ao(e), tc(e);
  });
}
function Wi(e) {
  const { gen: t, validateName: r } = e;
  e.evaluated = t.const("evaluated", (0, q._)`${r}.evaluated`), t.if((0, q._)`${e.evaluated}.dynamicProps`, () => t.assign((0, q._)`${e.evaluated}.props`, (0, q._)`undefined`)), t.if((0, q._)`${e.evaluated}.dynamicItems`, () => t.assign((0, q._)`${e.evaluated}.items`, (0, q._)`undefined`));
}
function As(e, t) {
  const r = typeof e == "object" && e[t.schemaId];
  return r && (t.code.source || t.code.process) ? (0, q._)`/*# sourceURL=${r} */` : q.nil;
}
function xi(e, t) {
  if (Co(e) && (jo(e), Ro(e))) {
    Xi(e, t);
    return;
  }
  (0, No.boolOrEmptySchema)(e, t);
}
function Ro({ schema: e, self: t }) {
  if (typeof e == "boolean")
    return !e;
  for (const r in e)
    if (t.RULES.all[r])
      return !0;
  return !1;
}
function Co(e) {
  return typeof e.schema != "boolean";
}
function Xi(e, t) {
  const { schema: r, gen: n, opts: s } = e;
  s.$comment && r.$comment && Io(e), Zi(e), ec(e);
  const o = n.const("_errs", G.default.errors);
  Ao(e, o), n.var(t, (0, q._)`${o} === ${G.default.errors}`);
}
function jo(e) {
  (0, xe.checkUnknownRules)(e), Yi(e);
}
function Ao(e, t) {
  if (e.opts.jtd)
    return Is(e, [], !1, t);
  const r = (0, js.getSchemaTypes)(e.schema), n = (0, js.coerceAndCheckDataType)(e, r);
  Is(e, r, !n, t);
}
function Yi(e) {
  const { schema: t, errSchemaPath: r, opts: n, self: s } = e;
  t.$ref && n.ignoreKeywordsWithRef && (0, xe.schemaHasRulesButRef)(t, s.RULES) && s.logger.warn(`$ref: keywords ignored in schema at path "${r}"`);
}
function Qi(e) {
  const { schema: t, opts: r } = e;
  t.default !== void 0 && r.useDefaults && r.strictSchema && (0, xe.checkStrictMode)(e, "default is ignored in the schema root");
}
function Zi(e) {
  const t = e.schema[e.opts.schemaId];
  t && (e.baseId = (0, Hi.resolveUrl)(e.opts.uriResolver, e.baseId, t));
}
function ec(e) {
  if (e.schema.$async && !e.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function Io({ gen: e, schemaEnv: t, schema: r, errSchemaPath: n, opts: s }) {
  const o = r.$comment;
  if (s.$comment === !0)
    e.code((0, q._)`${G.default.self}.logger.log(${o})`);
  else if (typeof s.$comment == "function") {
    const a = (0, q.str)`${n}/$comment`, c = e.scopeValue("root", { ref: t.root });
    e.code((0, q._)`${G.default.self}.opts.$comment(${o}, ${a}, ${c}.schema)`);
  }
}
function tc(e) {
  const { gen: t, schemaEnv: r, validateName: n, ValidationError: s, opts: o } = e;
  r.$async ? t.if((0, q._)`${G.default.errors} === 0`, () => t.return(G.default.data), () => t.throw((0, q._)`new ${s}(${G.default.vErrors})`)) : (t.assign((0, q._)`${n}.errors`, G.default.vErrors), o.unevaluated && rc(e), t.return((0, q._)`${G.default.errors} === 0`));
}
function rc({ gen: e, evaluated: t, props: r, items: n }) {
  r instanceof q.Name && e.assign((0, q._)`${t}.props`, r), n instanceof q.Name && e.assign((0, q._)`${t}.items`, n);
}
function Is(e, t, r, n) {
  const { gen: s, schema: o, data: a, allErrors: c, opts: f, self: i } = e, { RULES: u } = i;
  if (o.$ref && (f.ignoreKeywordsWithRef || !(0, xe.schemaHasRulesButRef)(o, u))) {
    s.block(() => Mo(e, "$ref", u.all.$ref.definition));
    return;
  }
  f.jtd || nc(e, t), s.block(() => {
    for (const w of u.rules)
      l(w);
    l(u.post);
  });
  function l(w) {
    (0, Cn.shouldUseGroup)(o, w) && (w.type ? (s.if((0, Dr.checkDataType)(w.type, a, f.strictNumbers)), Ds(e, w), t.length === 1 && t[0] === w.type && r && (s.else(), (0, Dr.reportTypeError)(e)), s.endIf()) : Ds(e, w), c || s.if((0, q._)`${G.default.errors} === ${n || 0}`));
  }
}
function Ds(e, t) {
  const { gen: r, schema: n, opts: { useDefaults: s } } = e;
  s && (0, qi.assignDefaults)(e, t.type), r.block(() => {
    for (const o of t.rules)
      (0, Cn.shouldUseRule)(n, o) && Mo(e, o.keyword, o.definition, t.type);
  });
}
function nc(e, t) {
  e.schemaEnv.meta || !e.opts.strictTypes || (sc(e, t), e.opts.allowUnionTypes || oc(e, t), ac(e, e.dataTypes));
}
function sc(e, t) {
  if (t.length) {
    if (!e.dataTypes.length) {
      e.dataTypes = t;
      return;
    }
    t.forEach((r) => {
      Do(e.dataTypes, r) || jn(e, `type "${r}" not allowed by context "${e.dataTypes.join(",")}"`);
    }), cc(e, t);
  }
}
function oc(e, t) {
  t.length > 1 && !(t.length === 2 && t.includes("null")) && jn(e, "use allowUnionTypes to allow union type keyword");
}
function ac(e, t) {
  const r = e.self.RULES.all;
  for (const n in r) {
    const s = r[n];
    if (typeof s == "object" && (0, Cn.shouldUseRule)(e.schema, s)) {
      const { type: o } = s.definition;
      o.length && !o.some((a) => ic(t, a)) && jn(e, `missing type "${o.join(",")}" for keyword "${n}"`);
    }
  }
}
function ic(e, t) {
  return e.includes(t) || t === "number" && e.includes("integer");
}
function Do(e, t) {
  return e.includes(t) || t === "integer" && e.includes("number");
}
function cc(e, t) {
  const r = [];
  for (const n of e.dataTypes)
    Do(t, n) ? r.push(n) : t.includes("integer") && n === "number" && r.push("integer");
  e.dataTypes = r;
}
function jn(e, t) {
  const r = e.schemaEnv.baseId + e.errSchemaPath;
  t += ` at "${r}" (strictTypes)`, (0, xe.checkStrictMode)(e, t, e.opts.strictTypes);
}
class ko {
  constructor(t, r, n) {
    if ((0, Yt.validateKeywordUsage)(t, r, n), this.gen = t.gen, this.allErrors = t.allErrors, this.keyword = n, this.data = t.data, this.schema = t.schema[n], this.$data = r.$data && t.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, xe.schemaRefOrVal)(t, this.schema, n, this.$data), this.schemaType = r.schemaType, this.parentSchema = t.schema, this.params = {}, this.it = t, this.def = r, this.$data)
      this.schemaCode = t.gen.const("vSchema", Fo(this.$data, t));
    else if (this.schemaCode = this.schemaValue, !(0, Yt.validSchemaType)(this.schema, r.schemaType, r.allowUndefined))
      throw new Error(`${n} value must be ${JSON.stringify(r.schemaType)}`);
    ("code" in r ? r.trackErrors : r.errors !== !1) && (this.errsCount = t.gen.const("_errs", G.default.errors));
  }
  result(t, r, n) {
    this.failResult((0, q.not)(t), r, n);
  }
  failResult(t, r, n) {
    this.gen.if(t), n ? n() : this.error(), r ? (this.gen.else(), r(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  pass(t, r) {
    this.failResult((0, q.not)(t), void 0, r);
  }
  fail(t) {
    if (t === void 0) {
      this.error(), this.allErrors || this.gen.if(!1);
      return;
    }
    this.gen.if(t), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  fail$data(t) {
    if (!this.$data)
      return this.fail(t);
    const { schemaCode: r } = this;
    this.fail((0, q._)`${r} !== undefined && (${(0, q.or)(this.invalid$data(), t)})`);
  }
  error(t, r, n) {
    if (r) {
      this.setParams(r), this._error(t, n), this.setParams({});
      return;
    }
    this._error(t, n);
  }
  _error(t, r) {
    (t ? Gt.reportExtraError : Gt.reportError)(this, this.def.error, r);
  }
  $dataError() {
    (0, Gt.reportError)(this, this.def.$dataError || Gt.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, Gt.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(t) {
    this.allErrors || this.gen.if(t);
  }
  setParams(t, r) {
    r ? Object.assign(this.params, t) : this.params = t;
  }
  block$data(t, r, n = q.nil) {
    this.gen.block(() => {
      this.check$data(t, n), r();
    });
  }
  check$data(t = q.nil, r = q.nil) {
    if (!this.$data)
      return;
    const { gen: n, schemaCode: s, schemaType: o, def: a } = this;
    n.if((0, q.or)((0, q._)`${s} === undefined`, r)), t !== q.nil && n.assign(t, !0), (o.length || a.validateSchema) && (n.elseIf(this.invalid$data()), this.$dataError(), t !== q.nil && n.assign(t, !1)), n.else();
  }
  invalid$data() {
    const { gen: t, schemaCode: r, schemaType: n, def: s, it: o } = this;
    return (0, q.or)(a(), c());
    function a() {
      if (n.length) {
        if (!(r instanceof q.Name))
          throw new Error("ajv implementation error");
        const f = Array.isArray(n) ? n : [n];
        return (0, q._)`${(0, Dr.checkDataTypes)(f, r, o.opts.strictNumbers, Dr.DataType.Wrong)}`;
      }
      return q.nil;
    }
    function c() {
      if (s.validateSchema) {
        const f = t.scopeValue("validate$data", { ref: s.validateSchema });
        return (0, q._)`!${f}(${r})`;
      }
      return q.nil;
    }
  }
  subschema(t, r) {
    const n = (0, tn.getSubschema)(this.it, t);
    (0, tn.extendSubschemaData)(n, this.it, t), (0, tn.extendSubschemaMode)(n, t);
    const s = { ...this.it, ...n, items: void 0, props: void 0 };
    return xi(s, r), s;
  }
  mergeEvaluated(t, r) {
    const { it: n, gen: s } = this;
    n.opts.unevaluated && (n.props !== !0 && t.props !== void 0 && (n.props = xe.mergeEvaluated.props(s, t.props, n.props, r)), n.items !== !0 && t.items !== void 0 && (n.items = xe.mergeEvaluated.items(s, t.items, n.items, r)));
  }
  mergeValidEvaluated(t, r) {
    const { it: n, gen: s } = this;
    if (n.opts.unevaluated && (n.props !== !0 || n.items !== !0))
      return s.if(r, () => this.mergeEvaluated(t, q.Name)), !0;
  }
}
Ie.KeywordCxt = ko;
function Mo(e, t, r, n) {
  const s = new ko(e, r, t);
  "code" in r ? r.code(s, n) : s.$data && r.validate ? (0, Yt.funcKeywordCode)(s, r) : "macro" in r ? (0, Yt.macroKeywordCode)(s, r) : (r.compile || r.validate) && (0, Yt.funcKeywordCode)(s, r);
}
const uc = /^\/(?:[^~]|~0|~1)*$/, lc = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function Fo(e, { dataLevel: t, dataNames: r, dataPathArr: n }) {
  let s, o;
  if (e === "")
    return G.default.rootData;
  if (e[0] === "/") {
    if (!uc.test(e))
      throw new Error(`Invalid JSON-pointer: ${e}`);
    s = e, o = G.default.rootData;
  } else {
    const i = lc.exec(e);
    if (!i)
      throw new Error(`Invalid JSON-pointer: ${e}`);
    const u = +i[1];
    if (s = i[2], s === "#") {
      if (u >= t)
        throw new Error(f("property/index", u));
      return n[t - u];
    }
    if (u > t)
      throw new Error(f("data", u));
    if (o = r[t - u], !s)
      return o;
  }
  let a = o;
  const c = s.split("/");
  for (const i of c)
    i && (o = (0, q._)`${o}${(0, q.getProperty)((0, xe.unescapeJsonPointer)(i))}`, a = (0, q._)`${a} && ${o}`);
  return a;
  function f(i, u) {
    return `Cannot access ${i} ${u} levels up, current level is ${t}`;
  }
}
Ie.getData = Fo;
var ur = {};
Object.defineProperty(ur, "__esModule", { value: !0 });
class dc extends Error {
  constructor(t) {
    super("validation failed"), this.errors = t, this.ajv = this.validation = !0;
  }
}
ur.default = dc;
var lr = {};
Object.defineProperty(lr, "__esModule", { value: !0 });
const rn = ve;
class fc extends Error {
  constructor(t, r, n, s) {
    super(s || `can't resolve reference ${n} from id ${r}`), this.missingRef = (0, rn.resolveUrl)(t, r, n), this.missingSchema = (0, rn.normalizeId)((0, rn.getFullPath)(t, this.missingRef));
  }
}
lr.default = fc;
var Se = {};
Object.defineProperty(Se, "__esModule", { value: !0 });
Se.resolveSchema = Se.getCompilingSchema = Se.resolveRef = Se.compileSchema = Se.SchemaEnv = void 0;
const Ce = W, pc = ur, lt = Be, Ae = ve, ks = re, hc = Ie;
class Br {
  constructor(t) {
    var r;
    this.refs = {}, this.dynamicAnchors = {};
    let n;
    typeof t.schema == "object" && (n = t.schema), this.schema = t.schema, this.schemaId = t.schemaId, this.root = t.root || this, this.baseId = (r = t.baseId) !== null && r !== void 0 ? r : (0, Ae.normalizeId)(n == null ? void 0 : n[t.schemaId || "$id"]), this.schemaPath = t.schemaPath, this.localRefs = t.localRefs, this.meta = t.meta, this.$async = n == null ? void 0 : n.$async, this.refs = {};
  }
}
Se.SchemaEnv = Br;
function An(e) {
  const t = Uo.call(this, e);
  if (t)
    return t;
  const r = (0, Ae.getFullPath)(this.opts.uriResolver, e.root.baseId), { es5: n, lines: s } = this.opts.code, { ownProperties: o } = this.opts, a = new Ce.CodeGen(this.scope, { es5: n, lines: s, ownProperties: o });
  let c;
  e.$async && (c = a.scopeValue("Error", {
    ref: pc.default,
    code: (0, Ce._)`require("ajv/dist/runtime/validation_error").default`
  }));
  const f = a.scopeName("validate");
  e.validateName = f;
  const i = {
    gen: a,
    allErrors: this.opts.allErrors,
    data: lt.default.data,
    parentData: lt.default.parentData,
    parentDataProperty: lt.default.parentDataProperty,
    dataNames: [lt.default.data],
    dataPathArr: [Ce.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: a.scopeValue("schema", this.opts.code.source === !0 ? { ref: e.schema, code: (0, Ce.stringify)(e.schema) } : { ref: e.schema }),
    validateName: f,
    ValidationError: c,
    schema: e.schema,
    schemaEnv: e,
    rootId: r,
    baseId: e.baseId || r,
    schemaPath: Ce.nil,
    errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, Ce._)`""`,
    opts: this.opts,
    self: this
  };
  let u;
  try {
    this._compilations.add(e), (0, hc.validateFunctionCode)(i), a.optimize(this.opts.code.optimize);
    const l = a.toString();
    u = `${a.scopeRefs(lt.default.scope)}return ${l}`, this.opts.code.process && (u = this.opts.code.process(u, e));
    const b = new Function(`${lt.default.self}`, `${lt.default.scope}`, u)(this, this.scope.get());
    if (this.scope.value(f, { ref: b }), b.errors = null, b.schema = e.schema, b.schemaEnv = e, e.$async && (b.$async = !0), this.opts.code.source === !0 && (b.source = { validateName: f, validateCode: l, scopeValues: a._values }), this.opts.unevaluated) {
      const { props: h, items: y } = i;
      b.evaluated = {
        props: h instanceof Ce.Name ? void 0 : h,
        items: y instanceof Ce.Name ? void 0 : y,
        dynamicProps: h instanceof Ce.Name,
        dynamicItems: y instanceof Ce.Name
      }, b.source && (b.source.evaluated = (0, Ce.stringify)(b.evaluated));
    }
    return e.validate = b, e;
  } catch (l) {
    throw delete e.validate, delete e.validateName, u && this.logger.error("Error compiling schema, function code:", u), l;
  } finally {
    this._compilations.delete(e);
  }
}
Se.compileSchema = An;
function mc(e, t, r) {
  var n;
  r = (0, Ae.resolveUrl)(this.opts.uriResolver, t, r);
  const s = e.refs[r];
  if (s)
    return s;
  let o = vc.call(this, e, r);
  if (o === void 0) {
    const a = (n = e.localRefs) === null || n === void 0 ? void 0 : n[r], { schemaId: c } = this.opts;
    a && (o = new Br({ schema: a, schemaId: c, root: e, baseId: t }));
  }
  if (o !== void 0)
    return e.refs[r] = yc.call(this, o);
}
Se.resolveRef = mc;
function yc(e) {
  return (0, Ae.inlineRef)(e.schema, this.opts.inlineRefs) ? e.schema : e.validate ? e : An.call(this, e);
}
function Uo(e) {
  for (const t of this._compilations)
    if (gc(t, e))
      return t;
}
Se.getCompilingSchema = Uo;
function gc(e, t) {
  return e.schema === t.schema && e.root === t.root && e.baseId === t.baseId;
}
function vc(e, t) {
  let r;
  for (; typeof (r = this.refs[t]) == "string"; )
    t = r;
  return r || this.schemas[t] || Gr.call(this, e, t);
}
function Gr(e, t) {
  const r = this.opts.uriResolver.parse(t), n = (0, Ae._getFullPath)(this.opts.uriResolver, r);
  let s = (0, Ae.getFullPath)(this.opts.uriResolver, e.baseId, void 0);
  if (Object.keys(e.schema).length > 0 && n === s)
    return nn.call(this, r, e);
  const o = (0, Ae.normalizeId)(n), a = this.refs[o] || this.schemas[o];
  if (typeof a == "string") {
    const c = Gr.call(this, e, a);
    return typeof (c == null ? void 0 : c.schema) != "object" ? void 0 : nn.call(this, r, c);
  }
  if (typeof (a == null ? void 0 : a.schema) == "object") {
    if (a.validate || An.call(this, a), o === (0, Ae.normalizeId)(t)) {
      const { schema: c } = a, { schemaId: f } = this.opts, i = c[f];
      return i && (s = (0, Ae.resolveUrl)(this.opts.uriResolver, s, i)), new Br({ schema: c, schemaId: f, root: e, baseId: s });
    }
    return nn.call(this, r, a);
  }
}
Se.resolveSchema = Gr;
const $c = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function nn(e, { baseId: t, schema: r, root: n }) {
  var s;
  if (((s = e.fragment) === null || s === void 0 ? void 0 : s[0]) !== "/")
    return;
  for (const c of e.fragment.slice(1).split("/")) {
    if (typeof r == "boolean")
      return;
    const f = r[(0, ks.unescapeFragment)(c)];
    if (f === void 0)
      return;
    r = f;
    const i = typeof r == "object" && r[this.opts.schemaId];
    !$c.has(c) && i && (t = (0, Ae.resolveUrl)(this.opts.uriResolver, t, i));
  }
  let o;
  if (typeof r != "boolean" && r.$ref && !(0, ks.schemaHasRulesButRef)(r, this.RULES)) {
    const c = (0, Ae.resolveUrl)(this.opts.uriResolver, t, r.$ref);
    o = Gr.call(this, n, c);
  }
  const { schemaId: a } = this.opts;
  if (o = o || new Br({ schema: r, schemaId: a, root: n, baseId: t }), o.schema !== o.root.schema)
    return o;
}
const _c = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", wc = "Meta-schema for $data reference (JSON AnySchema extension proposal)", bc = "object", Ec = [
  "$data"
], Sc = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
}, Pc = !1, Oc = {
  $id: _c,
  description: wc,
  type: bc,
  required: Ec,
  properties: Sc,
  additionalProperties: Pc
};
var In = {}, kr = {}, Nc = {
  get exports() {
    return kr;
  },
  set exports(e) {
    kr = e;
  }
};
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(e, t) {
  (function(r, n) {
    n(t);
  })(Ga, function(r) {
    function n() {
      for (var g = arguments.length, p = Array(g), $ = 0; $ < g; $++)
        p[$] = arguments[$];
      if (p.length > 1) {
        p[0] = p[0].slice(0, -1);
        for (var R = p.length - 1, T = 1; T < R; ++T)
          p[T] = p[T].slice(1, -1);
        return p[R] = p[R].slice(1), p.join("");
      } else
        return p[0];
    }
    function s(g) {
      return "(?:" + g + ")";
    }
    function o(g) {
      return g === void 0 ? "undefined" : g === null ? "null" : Object.prototype.toString.call(g).split(" ").pop().split("]").shift().toLowerCase();
    }
    function a(g) {
      return g.toUpperCase();
    }
    function c(g) {
      return g != null ? g instanceof Array ? g : typeof g.length != "number" || g.split || g.setInterval || g.call ? [g] : Array.prototype.slice.call(g) : [];
    }
    function f(g, p) {
      var $ = g;
      if (p)
        for (var R in p)
          $[R] = p[R];
      return $;
    }
    function i(g) {
      var p = "[A-Za-z]", $ = "[0-9]", R = n($, "[A-Fa-f]"), T = s(s("%[EFef]" + R + "%" + R + R + "%" + R + R) + "|" + s("%[89A-Fa-f]" + R + "%" + R + R) + "|" + s("%" + R + R)), H = "[\\:\\/\\?\\#\\[\\]\\@]", K = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", ee = n(H, K), oe = g ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", le = g ? "[\\uE000-\\uF8FF]" : "[]", Q = n(p, $, "[\\-\\.\\_\\~]", oe);
      s(p + n(p, $, "[\\+\\-\\.]") + "*"), s(s(T + "|" + n(Q, K, "[\\:]")) + "*");
      var ne = s(s("25[0-5]") + "|" + s("2[0-4]" + $) + "|" + s("1" + $ + $) + "|" + s("0?[1-9]" + $) + "|0?0?" + $), de = s(ne + "\\." + ne + "\\." + ne + "\\." + ne), J = s(R + "{1,4}"), ie = s(s(J + "\\:" + J) + "|" + de), he = s(s(J + "\\:") + "{6}" + ie), ce = s("\\:\\:" + s(J + "\\:") + "{5}" + ie), Ze = s(s(J) + "?\\:\\:" + s(J + "\\:") + "{4}" + ie), Fe = s(s(s(J + "\\:") + "{0,1}" + J) + "?\\:\\:" + s(J + "\\:") + "{3}" + ie), Ue = s(s(s(J + "\\:") + "{0,2}" + J) + "?\\:\\:" + s(J + "\\:") + "{2}" + ie), St = s(s(s(J + "\\:") + "{0,3}" + J) + "?\\:\\:" + J + "\\:" + ie), ct = s(s(s(J + "\\:") + "{0,4}" + J) + "?\\:\\:" + ie), Te = s(s(s(J + "\\:") + "{0,5}" + J) + "?\\:\\:" + J), ze = s(s(s(J + "\\:") + "{0,6}" + J) + "?\\:\\:"), ut = s([he, ce, Ze, Fe, Ue, St, ct, Te, ze].join("|")), Ge = s(s(Q + "|" + T) + "+");
      s("[vV]" + R + "+\\." + n(Q, K, "[\\:]") + "+"), s(s(T + "|" + n(Q, K)) + "*");
      var Kt = s(T + "|" + n(Q, K, "[\\:\\@]"));
      return s(s(T + "|" + n(Q, K, "[\\@]")) + "+"), s(s(Kt + "|" + n("[\\/\\?]", le)) + "*"), {
        NOT_SCHEME: new RegExp(n("[^]", p, $, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(n("[^\\%\\:]", Q, K), "g"),
        NOT_HOST: new RegExp(n("[^\\%\\[\\]\\:]", Q, K), "g"),
        NOT_PATH: new RegExp(n("[^\\%\\/\\:\\@]", Q, K), "g"),
        NOT_PATH_NOSCHEME: new RegExp(n("[^\\%\\/\\@]", Q, K), "g"),
        NOT_QUERY: new RegExp(n("[^\\%]", Q, K, "[\\:\\@\\/\\?]", le), "g"),
        NOT_FRAGMENT: new RegExp(n("[^\\%]", Q, K, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(n("[^]", Q, K), "g"),
        UNRESERVED: new RegExp(Q, "g"),
        OTHER_CHARS: new RegExp(n("[^\\%]", Q, ee), "g"),
        PCT_ENCODED: new RegExp(T, "g"),
        IPV4ADDRESS: new RegExp("^(" + de + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + ut + ")" + s(s("\\%25|\\%(?!" + R + "{2})") + "(" + Ge + ")") + "?\\]?$")
        //RFC 6874, with relaxed parsing rules
      };
    }
    var u = i(!1), l = i(!0), w = function() {
      function g(p, $) {
        var R = [], T = !0, H = !1, K = void 0;
        try {
          for (var ee = p[Symbol.iterator](), oe; !(T = (oe = ee.next()).done) && (R.push(oe.value), !($ && R.length === $)); T = !0)
            ;
        } catch (le) {
          H = !0, K = le;
        } finally {
          try {
            !T && ee.return && ee.return();
          } finally {
            if (H)
              throw K;
          }
        }
        return R;
      }
      return function(p, $) {
        if (Array.isArray(p))
          return p;
        if (Symbol.iterator in Object(p))
          return g(p, $);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), b = function(g) {
      if (Array.isArray(g)) {
        for (var p = 0, $ = Array(g.length); p < g.length; p++)
          $[p] = g[p];
        return $;
      } else
        return Array.from(g);
    }, h = 2147483647, y = 36, _ = 1, m = 26, E = 38, O = 700, j = 72, k = 128, S = "-", C = /^xn--/, M = /[^\0-\x7E]/, F = /[\x2E\u3002\uFF0E\uFF61]/g, L = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, x = y - _, B = Math.floor, pe = String.fromCharCode;
    function se(g) {
      throw new RangeError(L[g]);
    }
    function Oe(g, p) {
      for (var $ = [], R = g.length; R--; )
        $[R] = p(g[R]);
      return $;
    }
    function ot(g, p) {
      var $ = g.split("@"), R = "";
      $.length > 1 && (R = $[0] + "@", g = $[1]), g = g.replace(F, ".");
      var T = g.split("."), H = Oe(T, p).join(".");
      return R + H;
    }
    function yt(g) {
      for (var p = [], $ = 0, R = g.length; $ < R; ) {
        var T = g.charCodeAt($++);
        if (T >= 55296 && T <= 56319 && $ < R) {
          var H = g.charCodeAt($++);
          (H & 64512) == 56320 ? p.push(((T & 1023) << 10) + (H & 1023) + 65536) : (p.push(T), $--);
        } else
          p.push(T);
      }
      return p;
    }
    var Mt = function(p) {
      return String.fromCodePoint.apply(String, b(p));
    }, gt = function(p) {
      return p - 48 < 10 ? p - 22 : p - 65 < 26 ? p - 65 : p - 97 < 26 ? p - 97 : y;
    }, U = function(p, $) {
      return p + 22 + 75 * (p < 26) - (($ != 0) << 5);
    }, P = function(p, $, R) {
      var T = 0;
      for (
        p = R ? B(p / O) : p >> 1, p += B(p / $);
        /* no initialization */
        p > x * m >> 1;
        T += y
      )
        p = B(p / x);
      return B(T + (x + 1) * p / (p + E));
    }, D = function(p) {
      var $ = [], R = p.length, T = 0, H = k, K = j, ee = p.lastIndexOf(S);
      ee < 0 && (ee = 0);
      for (var oe = 0; oe < ee; ++oe)
        p.charCodeAt(oe) >= 128 && se("not-basic"), $.push(p.charCodeAt(oe));
      for (var le = ee > 0 ? ee + 1 : 0; le < R; ) {
        for (
          var Q = T, ne = 1, de = y;
          ;
          /* no condition */
          de += y
        ) {
          le >= R && se("invalid-input");
          var J = gt(p.charCodeAt(le++));
          (J >= y || J > B((h - T) / ne)) && se("overflow"), T += J * ne;
          var ie = de <= K ? _ : de >= K + m ? m : de - K;
          if (J < ie)
            break;
          var he = y - ie;
          ne > B(h / he) && se("overflow"), ne *= he;
        }
        var ce = $.length + 1;
        K = P(T - Q, ce, Q == 0), B(T / ce) > h - H && se("overflow"), H += B(T / ce), T %= ce, $.splice(T++, 0, H);
      }
      return String.fromCodePoint.apply(String, $);
    }, N = function(p) {
      var $ = [];
      p = yt(p);
      var R = p.length, T = k, H = 0, K = j, ee = !0, oe = !1, le = void 0;
      try {
        for (var Q = p[Symbol.iterator](), ne; !(ee = (ne = Q.next()).done); ee = !0) {
          var de = ne.value;
          de < 128 && $.push(pe(de));
        }
      } catch (Bt) {
        oe = !0, le = Bt;
      } finally {
        try {
          !ee && Q.return && Q.return();
        } finally {
          if (oe)
            throw le;
        }
      }
      var J = $.length, ie = J;
      for (J && $.push(S); ie < R; ) {
        var he = h, ce = !0, Ze = !1, Fe = void 0;
        try {
          for (var Ue = p[Symbol.iterator](), St; !(ce = (St = Ue.next()).done); ce = !0) {
            var ct = St.value;
            ct >= T && ct < he && (he = ct);
          }
        } catch (Bt) {
          Ze = !0, Fe = Bt;
        } finally {
          try {
            !ce && Ue.return && Ue.return();
          } finally {
            if (Ze)
              throw Fe;
          }
        }
        var Te = ie + 1;
        he - T > B((h - H) / Te) && se("overflow"), H += (he - T) * Te, T = he;
        var ze = !0, ut = !1, Ge = void 0;
        try {
          for (var Kt = p[Symbol.iterator](), Ps; !(ze = (Ps = Kt.next()).done); ze = !0) {
            var Os = Ps.value;
            if (Os < T && ++H > h && se("overflow"), Os == T) {
              for (
                var mr = H, yr = y;
                ;
                /* no condition */
                yr += y
              ) {
                var gr = yr <= K ? _ : yr >= K + m ? m : yr - K;
                if (mr < gr)
                  break;
                var Ns = mr - gr, Ts = y - gr;
                $.push(pe(U(gr + Ns % Ts, 0))), mr = B(Ns / Ts);
              }
              $.push(pe(U(mr, 0))), K = P(H, Te, ie == J), H = 0, ++ie;
            }
          }
        } catch (Bt) {
          ut = !0, Ge = Bt;
        } finally {
          try {
            !ze && Kt.return && Kt.return();
          } finally {
            if (ut)
              throw Ge;
          }
        }
        ++H, ++T;
      }
      return $.join("");
    }, d = function(p) {
      return ot(p, function($) {
        return C.test($) ? D($.slice(4).toLowerCase()) : $;
      });
    }, v = function(p) {
      return ot(p, function($) {
        return M.test($) ? "xn--" + N($) : $;
      });
    }, A = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: yt,
        encode: Mt
      },
      decode: D,
      encode: N,
      toASCII: v,
      toUnicode: d
    }, z = {};
    function V(g) {
      var p = g.charCodeAt(0), $ = void 0;
      return p < 16 ? $ = "%0" + p.toString(16).toUpperCase() : p < 128 ? $ = "%" + p.toString(16).toUpperCase() : p < 2048 ? $ = "%" + (p >> 6 | 192).toString(16).toUpperCase() + "%" + (p & 63 | 128).toString(16).toUpperCase() : $ = "%" + (p >> 12 | 224).toString(16).toUpperCase() + "%" + (p >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (p & 63 | 128).toString(16).toUpperCase(), $;
    }
    function Y(g) {
      for (var p = "", $ = 0, R = g.length; $ < R; ) {
        var T = parseInt(g.substr($ + 1, 2), 16);
        if (T < 128)
          p += String.fromCharCode(T), $ += 3;
        else if (T >= 194 && T < 224) {
          if (R - $ >= 6) {
            var H = parseInt(g.substr($ + 4, 2), 16);
            p += String.fromCharCode((T & 31) << 6 | H & 63);
          } else
            p += g.substr($, 6);
          $ += 6;
        } else if (T >= 224) {
          if (R - $ >= 9) {
            var K = parseInt(g.substr($ + 4, 2), 16), ee = parseInt(g.substr($ + 7, 2), 16);
            p += String.fromCharCode((T & 15) << 12 | (K & 63) << 6 | ee & 63);
          } else
            p += g.substr($, 9);
          $ += 9;
        } else
          p += g.substr($, 3), $ += 3;
      }
      return p;
    }
    function Z(g, p) {
      function $(R) {
        var T = Y(R);
        return T.match(p.UNRESERVED) ? T : R;
      }
      return g.scheme && (g.scheme = String(g.scheme).replace(p.PCT_ENCODED, $).toLowerCase().replace(p.NOT_SCHEME, "")), g.userinfo !== void 0 && (g.userinfo = String(g.userinfo).replace(p.PCT_ENCODED, $).replace(p.NOT_USERINFO, V).replace(p.PCT_ENCODED, a)), g.host !== void 0 && (g.host = String(g.host).replace(p.PCT_ENCODED, $).toLowerCase().replace(p.NOT_HOST, V).replace(p.PCT_ENCODED, a)), g.path !== void 0 && (g.path = String(g.path).replace(p.PCT_ENCODED, $).replace(g.scheme ? p.NOT_PATH : p.NOT_PATH_NOSCHEME, V).replace(p.PCT_ENCODED, a)), g.query !== void 0 && (g.query = String(g.query).replace(p.PCT_ENCODED, $).replace(p.NOT_QUERY, V).replace(p.PCT_ENCODED, a)), g.fragment !== void 0 && (g.fragment = String(g.fragment).replace(p.PCT_ENCODED, $).replace(p.NOT_FRAGMENT, V).replace(p.PCT_ENCODED, a)), g;
    }
    function ue(g) {
      return g.replace(/^0*(.*)/, "$1") || "0";
    }
    function De(g, p) {
      var $ = g.match(p.IPV4ADDRESS) || [], R = w($, 2), T = R[1];
      return T ? T.split(".").map(ue).join(".") : g;
    }
    function vt(g, p) {
      var $ = g.match(p.IPV6ADDRESS) || [], R = w($, 3), T = R[1], H = R[2];
      if (T) {
        for (var K = T.toLowerCase().split("::").reverse(), ee = w(K, 2), oe = ee[0], le = ee[1], Q = le ? le.split(":").map(ue) : [], ne = oe.split(":").map(ue), de = p.IPV4ADDRESS.test(ne[ne.length - 1]), J = de ? 7 : 8, ie = ne.length - J, he = Array(J), ce = 0; ce < J; ++ce)
          he[ce] = Q[ce] || ne[ie + ce] || "";
        de && (he[J - 1] = De(he[J - 1], p));
        var Ze = he.reduce(function(Te, ze, ut) {
          if (!ze || ze === "0") {
            var Ge = Te[Te.length - 1];
            Ge && Ge.index + Ge.length === ut ? Ge.length++ : Te.push({ index: ut, length: 1 });
          }
          return Te;
        }, []), Fe = Ze.sort(function(Te, ze) {
          return ze.length - Te.length;
        })[0], Ue = void 0;
        if (Fe && Fe.length > 1) {
          var St = he.slice(0, Fe.index), ct = he.slice(Fe.index + Fe.length);
          Ue = St.join(":") + "::" + ct.join(":");
        } else
          Ue = he.join(":");
        return H && (Ue += "%" + H), Ue;
      } else
        return g;
    }
    var Ft = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, Ut = "".match(/(){0}/)[1] === void 0;
    function Pe(g) {
      var p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, $ = {}, R = p.iri !== !1 ? l : u;
      p.reference === "suffix" && (g = (p.scheme ? p.scheme + ":" : "") + "//" + g);
      var T = g.match(Ft);
      if (T) {
        Ut ? ($.scheme = T[1], $.userinfo = T[3], $.host = T[4], $.port = parseInt(T[5], 10), $.path = T[6] || "", $.query = T[7], $.fragment = T[8], isNaN($.port) && ($.port = T[5])) : ($.scheme = T[1] || void 0, $.userinfo = g.indexOf("@") !== -1 ? T[3] : void 0, $.host = g.indexOf("//") !== -1 ? T[4] : void 0, $.port = parseInt(T[5], 10), $.path = T[6] || "", $.query = g.indexOf("?") !== -1 ? T[7] : void 0, $.fragment = g.indexOf("#") !== -1 ? T[8] : void 0, isNaN($.port) && ($.port = g.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? T[4] : void 0)), $.host && ($.host = vt(De($.host, R), R)), $.scheme === void 0 && $.userinfo === void 0 && $.host === void 0 && $.port === void 0 && !$.path && $.query === void 0 ? $.reference = "same-document" : $.scheme === void 0 ? $.reference = "relative" : $.fragment === void 0 ? $.reference = "absolute" : $.reference = "uri", p.reference && p.reference !== "suffix" && p.reference !== $.reference && ($.error = $.error || "URI is not a " + p.reference + " reference.");
        var H = z[(p.scheme || $.scheme || "").toLowerCase()];
        if (!p.unicodeSupport && (!H || !H.unicodeSupport)) {
          if ($.host && (p.domainHost || H && H.domainHost))
            try {
              $.host = A.toASCII($.host.replace(R.PCT_ENCODED, Y).toLowerCase());
            } catch (K) {
              $.error = $.error || "Host's domain name can not be converted to ASCII via punycode: " + K;
            }
          Z($, u);
        } else
          Z($, R);
        H && H.parse && H.parse($, p);
      } else
        $.error = $.error || "URI can not be parsed.";
      return $;
    }
    function zt(g, p) {
      var $ = p.iri !== !1 ? l : u, R = [];
      return g.userinfo !== void 0 && (R.push(g.userinfo), R.push("@")), g.host !== void 0 && R.push(vt(De(String(g.host), $), $).replace($.IPV6ADDRESS, function(T, H, K) {
        return "[" + H + (K ? "%25" + K : "") + "]";
      })), (typeof g.port == "number" || typeof g.port == "string") && (R.push(":"), R.push(String(g.port))), R.length ? R.join("") : void 0;
    }
    var $t = /^\.\.?\//, _t = /^\/\.(\/|$)/, wt = /^\/\.\.(\/|$)/, Vt = /^\/?(?:.|\n)*?(?=\/|$)/;
    function ke(g) {
      for (var p = []; g.length; )
        if (g.match($t))
          g = g.replace($t, "");
        else if (g.match(_t))
          g = g.replace(_t, "/");
        else if (g.match(wt))
          g = g.replace(wt, "/"), p.pop();
        else if (g === "." || g === "..")
          g = "";
        else {
          var $ = g.match(Vt);
          if ($) {
            var R = $[0];
            g = g.slice(R.length), p.push(R);
          } else
            throw new Error("Unexpected dot segment condition");
        }
      return p.join("");
    }
    function be(g) {
      var p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, $ = p.iri ? l : u, R = [], T = z[(p.scheme || g.scheme || "").toLowerCase()];
      if (T && T.serialize && T.serialize(g, p), g.host && !$.IPV6ADDRESS.test(g.host)) {
        if (p.domainHost || T && T.domainHost)
          try {
            g.host = p.iri ? A.toUnicode(g.host) : A.toASCII(g.host.replace($.PCT_ENCODED, Y).toLowerCase());
          } catch (ee) {
            g.error = g.error || "Host's domain name can not be converted to " + (p.iri ? "Unicode" : "ASCII") + " via punycode: " + ee;
          }
      }
      Z(g, $), p.reference !== "suffix" && g.scheme && (R.push(g.scheme), R.push(":"));
      var H = zt(g, p);
      if (H !== void 0 && (p.reference !== "suffix" && R.push("//"), R.push(H), g.path && g.path.charAt(0) !== "/" && R.push("/")), g.path !== void 0) {
        var K = g.path;
        !p.absolutePath && (!T || !T.absolutePath) && (K = ke(K)), H === void 0 && (K = K.replace(/^\/\//, "/%2F")), R.push(K);
      }
      return g.query !== void 0 && (R.push("?"), R.push(g.query)), g.fragment !== void 0 && (R.push("#"), R.push(g.fragment)), R.join("");
    }
    function bt(g, p) {
      var $ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, R = arguments[3], T = {};
      return R || (g = Pe(be(g, $), $), p = Pe(be(p, $), $)), $ = $ || {}, !$.tolerant && p.scheme ? (T.scheme = p.scheme, T.userinfo = p.userinfo, T.host = p.host, T.port = p.port, T.path = ke(p.path || ""), T.query = p.query) : (p.userinfo !== void 0 || p.host !== void 0 || p.port !== void 0 ? (T.userinfo = p.userinfo, T.host = p.host, T.port = p.port, T.path = ke(p.path || ""), T.query = p.query) : (p.path ? (p.path.charAt(0) === "/" ? T.path = ke(p.path) : ((g.userinfo !== void 0 || g.host !== void 0 || g.port !== void 0) && !g.path ? T.path = "/" + p.path : g.path ? T.path = g.path.slice(0, g.path.lastIndexOf("/") + 1) + p.path : T.path = p.path, T.path = ke(T.path)), T.query = p.query) : (T.path = g.path, p.query !== void 0 ? T.query = p.query : T.query = g.query), T.userinfo = g.userinfo, T.host = g.host, T.port = g.port), T.scheme = g.scheme), T.fragment = p.fragment, T;
    }
    function Lt(g, p, $) {
      var R = f({ scheme: "null" }, $);
      return be(bt(Pe(g, R), Pe(p, R), R, !0), R);
    }
    function at(g, p) {
      return typeof g == "string" ? g = be(Pe(g, p), p) : o(g) === "object" && (g = Pe(be(g, p), p)), g;
    }
    function qt(g, p, $) {
      return typeof g == "string" ? g = be(Pe(g, $), $) : o(g) === "object" && (g = be(g, $)), typeof p == "string" ? p = be(Pe(p, $), $) : o(p) === "object" && (p = be(p, $)), g === p;
    }
    function hr(g, p) {
      return g && g.toString().replace(!p || !p.iri ? u.ESCAPE : l.ESCAPE, V);
    }
    function Ne(g, p) {
      return g && g.toString().replace(!p || !p.iri ? u.PCT_ENCODED : l.PCT_ENCODED, Y);
    }
    var it = {
      scheme: "http",
      domainHost: !0,
      parse: function(p, $) {
        return p.host || (p.error = p.error || "HTTP URIs must have a host."), p;
      },
      serialize: function(p, $) {
        var R = String(p.scheme).toLowerCase() === "https";
        return (p.port === (R ? 443 : 80) || p.port === "") && (p.port = void 0), p.path || (p.path = "/"), p;
      }
    }, gs = {
      scheme: "https",
      domainHost: it.domainHost,
      parse: it.parse,
      serialize: it.serialize
    };
    function vs(g) {
      return typeof g.secure == "boolean" ? g.secure : String(g.scheme).toLowerCase() === "wss";
    }
    var Ht = {
      scheme: "ws",
      domainHost: !0,
      parse: function(p, $) {
        var R = p;
        return R.secure = vs(R), R.resourceName = (R.path || "/") + (R.query ? "?" + R.query : ""), R.path = void 0, R.query = void 0, R;
      },
      serialize: function(p, $) {
        if ((p.port === (vs(p) ? 443 : 80) || p.port === "") && (p.port = void 0), typeof p.secure == "boolean" && (p.scheme = p.secure ? "wss" : "ws", p.secure = void 0), p.resourceName) {
          var R = p.resourceName.split("?"), T = w(R, 2), H = T[0], K = T[1];
          p.path = H && H !== "/" ? H : void 0, p.query = K, p.resourceName = void 0;
        }
        return p.fragment = void 0, p;
      }
    }, $s = {
      scheme: "wss",
      domainHost: Ht.domainHost,
      parse: Ht.parse,
      serialize: Ht.serialize
    }, Pa = {}, _s = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", Me = "[0-9A-Fa-f]", Oa = s(s("%[EFef]" + Me + "%" + Me + Me + "%" + Me + Me) + "|" + s("%[89A-Fa-f]" + Me + "%" + Me + Me) + "|" + s("%" + Me + Me)), Na = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", Ta = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", Ra = n(Ta, '[\\"\\\\]'), Ca = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]", ja = new RegExp(_s, "g"), Et = new RegExp(Oa, "g"), Aa = new RegExp(n("[^]", Na, "[\\.]", '[\\"]', Ra), "g"), ws = new RegExp(n("[^]", _s, Ca), "g"), Ia = ws;
    function en(g) {
      var p = Y(g);
      return p.match(ja) ? p : g;
    }
    var bs = {
      scheme: "mailto",
      parse: function(p, $) {
        var R = p, T = R.to = R.path ? R.path.split(",") : [];
        if (R.path = void 0, R.query) {
          for (var H = !1, K = {}, ee = R.query.split("&"), oe = 0, le = ee.length; oe < le; ++oe) {
            var Q = ee[oe].split("=");
            switch (Q[0]) {
              case "to":
                for (var ne = Q[1].split(","), de = 0, J = ne.length; de < J; ++de)
                  T.push(ne[de]);
                break;
              case "subject":
                R.subject = Ne(Q[1], $);
                break;
              case "body":
                R.body = Ne(Q[1], $);
                break;
              default:
                H = !0, K[Ne(Q[0], $)] = Ne(Q[1], $);
                break;
            }
          }
          H && (R.headers = K);
        }
        R.query = void 0;
        for (var ie = 0, he = T.length; ie < he; ++ie) {
          var ce = T[ie].split("@");
          if (ce[0] = Ne(ce[0]), $.unicodeSupport)
            ce[1] = Ne(ce[1], $).toLowerCase();
          else
            try {
              ce[1] = A.toASCII(Ne(ce[1], $).toLowerCase());
            } catch (Ze) {
              R.error = R.error || "Email address's domain name can not be converted to ASCII via punycode: " + Ze;
            }
          T[ie] = ce.join("@");
        }
        return R;
      },
      serialize: function(p, $) {
        var R = p, T = c(p.to);
        if (T) {
          for (var H = 0, K = T.length; H < K; ++H) {
            var ee = String(T[H]), oe = ee.lastIndexOf("@"), le = ee.slice(0, oe).replace(Et, en).replace(Et, a).replace(Aa, V), Q = ee.slice(oe + 1);
            try {
              Q = $.iri ? A.toUnicode(Q) : A.toASCII(Ne(Q, $).toLowerCase());
            } catch (ie) {
              R.error = R.error || "Email address's domain name can not be converted to " + ($.iri ? "Unicode" : "ASCII") + " via punycode: " + ie;
            }
            T[H] = le + "@" + Q;
          }
          R.path = T.join(",");
        }
        var ne = p.headers = p.headers || {};
        p.subject && (ne.subject = p.subject), p.body && (ne.body = p.body);
        var de = [];
        for (var J in ne)
          ne[J] !== Pa[J] && de.push(J.replace(Et, en).replace(Et, a).replace(ws, V) + "=" + ne[J].replace(Et, en).replace(Et, a).replace(Ia, V));
        return de.length && (R.query = de.join("&")), R;
      }
    }, Da = /^([^\:]+)\:(.*)/, Es = {
      scheme: "urn",
      parse: function(p, $) {
        var R = p.path && p.path.match(Da), T = p;
        if (R) {
          var H = $.scheme || T.scheme || "urn", K = R[1].toLowerCase(), ee = R[2], oe = H + ":" + ($.nid || K), le = z[oe];
          T.nid = K, T.nss = ee, T.path = void 0, le && (T = le.parse(T, $));
        } else
          T.error = T.error || "URN can not be parsed.";
        return T;
      },
      serialize: function(p, $) {
        var R = $.scheme || p.scheme || "urn", T = p.nid, H = R + ":" + ($.nid || T), K = z[H];
        K && (p = K.serialize(p, $));
        var ee = p, oe = p.nss;
        return ee.path = (T || $.nid) + ":" + oe, ee;
      }
    }, ka = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, Ss = {
      scheme: "urn:uuid",
      parse: function(p, $) {
        var R = p;
        return R.uuid = R.nss, R.nss = void 0, !$.tolerant && (!R.uuid || !R.uuid.match(ka)) && (R.error = R.error || "UUID is not valid."), R;
      },
      serialize: function(p, $) {
        var R = p;
        return R.nss = (p.uuid || "").toLowerCase(), R;
      }
    };
    z[it.scheme] = it, z[gs.scheme] = gs, z[Ht.scheme] = Ht, z[$s.scheme] = $s, z[bs.scheme] = bs, z[Es.scheme] = Es, z[Ss.scheme] = Ss, r.SCHEMES = z, r.pctEncChar = V, r.pctDecChars = Y, r.parse = Pe, r.removeDotSegments = ke, r.serialize = be, r.resolveComponents = bt, r.resolve = Lt, r.normalize = at, r.equal = qt, r.escapeComponent = hr, r.unescapeComponent = Ne, Object.defineProperty(r, "__esModule", { value: !0 });
  });
})(Nc, kr);
Object.defineProperty(In, "__esModule", { value: !0 });
const zo = kr;
zo.code = 'require("ajv/dist/runtime/uri").default';
In.default = zo;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  var t = Ie;
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return t.KeywordCxt;
  } });
  var r = W;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return r._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return r.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return r.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return r.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return r.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
    return r.CodeGen;
  } });
  const n = ur, s = lr, o = ht, a = Se, c = W, f = ve, i = cr, u = re, l = Oc, w = In, b = (U, P) => new RegExp(U, P);
  b.code = "new RegExp";
  const h = ["removeAdditional", "useDefaults", "coerceTypes"], y = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]), _ = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  }, m = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  }, E = 200;
  function O(U) {
    var P, D, N, d, v, A, z, V, Y, Z, ue, De, vt, Ft, Ut, Pe, zt, $t, _t, wt, Vt, ke, be, bt, Lt;
    const at = U.strict, qt = (P = U.code) === null || P === void 0 ? void 0 : P.optimize, hr = qt === !0 || qt === void 0 ? 1 : qt || 0, Ne = (N = (D = U.code) === null || D === void 0 ? void 0 : D.regExp) !== null && N !== void 0 ? N : b, it = (d = U.uriResolver) !== null && d !== void 0 ? d : w.default;
    return {
      strictSchema: (A = (v = U.strictSchema) !== null && v !== void 0 ? v : at) !== null && A !== void 0 ? A : !0,
      strictNumbers: (V = (z = U.strictNumbers) !== null && z !== void 0 ? z : at) !== null && V !== void 0 ? V : !0,
      strictTypes: (Z = (Y = U.strictTypes) !== null && Y !== void 0 ? Y : at) !== null && Z !== void 0 ? Z : "log",
      strictTuples: (De = (ue = U.strictTuples) !== null && ue !== void 0 ? ue : at) !== null && De !== void 0 ? De : "log",
      strictRequired: (Ft = (vt = U.strictRequired) !== null && vt !== void 0 ? vt : at) !== null && Ft !== void 0 ? Ft : !1,
      code: U.code ? { ...U.code, optimize: hr, regExp: Ne } : { optimize: hr, regExp: Ne },
      loopRequired: (Ut = U.loopRequired) !== null && Ut !== void 0 ? Ut : E,
      loopEnum: (Pe = U.loopEnum) !== null && Pe !== void 0 ? Pe : E,
      meta: (zt = U.meta) !== null && zt !== void 0 ? zt : !0,
      messages: ($t = U.messages) !== null && $t !== void 0 ? $t : !0,
      inlineRefs: (_t = U.inlineRefs) !== null && _t !== void 0 ? _t : !0,
      schemaId: (wt = U.schemaId) !== null && wt !== void 0 ? wt : "$id",
      addUsedSchema: (Vt = U.addUsedSchema) !== null && Vt !== void 0 ? Vt : !0,
      validateSchema: (ke = U.validateSchema) !== null && ke !== void 0 ? ke : !0,
      validateFormats: (be = U.validateFormats) !== null && be !== void 0 ? be : !0,
      unicodeRegExp: (bt = U.unicodeRegExp) !== null && bt !== void 0 ? bt : !0,
      int32range: (Lt = U.int32range) !== null && Lt !== void 0 ? Lt : !0,
      uriResolver: it
    };
  }
  class j {
    constructor(P = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), P = this.opts = { ...P, ...O(P) };
      const { es5: D, lines: N } = this.opts.code;
      this.scope = new c.ValueScope({ scope: {}, prefixes: y, es5: D, lines: N }), this.logger = B(P.logger);
      const d = P.validateFormats;
      P.validateFormats = !1, this.RULES = (0, o.getRules)(), k.call(this, _, P, "NOT SUPPORTED"), k.call(this, m, P, "DEPRECATED", "warn"), this._metaOpts = L.call(this), P.formats && M.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), P.keywords && F.call(this, P.keywords), typeof P.meta == "object" && this.addMetaSchema(P.meta), C.call(this), P.validateFormats = d;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data: P, meta: D, schemaId: N } = this.opts;
      let d = l;
      N === "id" && (d = { ...l }, d.id = d.$id, delete d.$id), D && P && this.addMetaSchema(d, d[N], !1);
    }
    defaultMeta() {
      const { meta: P, schemaId: D } = this.opts;
      return this.opts.defaultMeta = typeof P == "object" ? P[D] || P : void 0;
    }
    validate(P, D) {
      let N;
      if (typeof P == "string") {
        if (N = this.getSchema(P), !N)
          throw new Error(`no schema with key or ref "${P}"`);
      } else
        N = this.compile(P);
      const d = N(D);
      return "$async" in N || (this.errors = N.errors), d;
    }
    compile(P, D) {
      const N = this._addSchema(P, D);
      return N.validate || this._compileSchemaEnv(N);
    }
    compileAsync(P, D) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: N } = this.opts;
      return d.call(this, P, D);
      async function d(Z, ue) {
        await v.call(this, Z.$schema);
        const De = this._addSchema(Z, ue);
        return De.validate || A.call(this, De);
      }
      async function v(Z) {
        Z && !this.getSchema(Z) && await d.call(this, { $ref: Z }, !0);
      }
      async function A(Z) {
        try {
          return this._compileSchemaEnv(Z);
        } catch (ue) {
          if (!(ue instanceof s.default))
            throw ue;
          return z.call(this, ue), await V.call(this, ue.missingSchema), A.call(this, Z);
        }
      }
      function z({ missingSchema: Z, missingRef: ue }) {
        if (this.refs[Z])
          throw new Error(`AnySchema ${Z} is loaded but ${ue} cannot be resolved`);
      }
      async function V(Z) {
        const ue = await Y.call(this, Z);
        this.refs[Z] || await v.call(this, ue.$schema), this.refs[Z] || this.addSchema(ue, Z, D);
      }
      async function Y(Z) {
        const ue = this._loading[Z];
        if (ue)
          return ue;
        try {
          return await (this._loading[Z] = N(Z));
        } finally {
          delete this._loading[Z];
        }
      }
    }
    // Adds schema to the instance
    addSchema(P, D, N, d = this.opts.validateSchema) {
      if (Array.isArray(P)) {
        for (const A of P)
          this.addSchema(A, void 0, N, d);
        return this;
      }
      let v;
      if (typeof P == "object") {
        const { schemaId: A } = this.opts;
        if (v = P[A], v !== void 0 && typeof v != "string")
          throw new Error(`schema ${A} must be string`);
      }
      return D = (0, f.normalizeId)(D || v), this._checkUnique(D), this.schemas[D] = this._addSchema(P, N, D, d, !0), this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(P, D, N = this.opts.validateSchema) {
      return this.addSchema(P, D, !0, N), this;
    }
    //  Validate schema against its meta-schema
    validateSchema(P, D) {
      if (typeof P == "boolean")
        return !0;
      let N;
      if (N = P.$schema, N !== void 0 && typeof N != "string")
        throw new Error("$schema must be a string");
      if (N = N || this.opts.defaultMeta || this.defaultMeta(), !N)
        return this.logger.warn("meta-schema not available"), this.errors = null, !0;
      const d = this.validate(N, P);
      if (!d && D) {
        const v = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(v);
        else
          throw new Error(v);
      }
      return d;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(P) {
      let D;
      for (; typeof (D = S.call(this, P)) == "string"; )
        P = D;
      if (D === void 0) {
        const { schemaId: N } = this.opts, d = new a.SchemaEnv({ schema: {}, schemaId: N });
        if (D = a.resolveSchema.call(this, d, P), !D)
          return;
        this.refs[P] = D;
      }
      return D.validate || this._compileSchemaEnv(D);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(P) {
      if (P instanceof RegExp)
        return this._removeAllSchemas(this.schemas, P), this._removeAllSchemas(this.refs, P), this;
      switch (typeof P) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          const D = S.call(this, P);
          return typeof D == "object" && this._cache.delete(D.schema), delete this.schemas[P], delete this.refs[P], this;
        }
        case "object": {
          const D = P;
          this._cache.delete(D);
          let N = P[this.opts.schemaId];
          return N && (N = (0, f.normalizeId)(N), delete this.schemas[N], delete this.refs[N]), this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(P) {
      for (const D of P)
        this.addKeyword(D);
      return this;
    }
    addKeyword(P, D) {
      let N;
      if (typeof P == "string")
        N = P, typeof D == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), D.keyword = N);
      else if (typeof P == "object" && D === void 0) {
        if (D = P, N = D.keyword, Array.isArray(N) && !N.length)
          throw new Error("addKeywords: keyword must be string or non-empty array");
      } else
        throw new Error("invalid addKeywords parameters");
      if (se.call(this, N, D), !D)
        return (0, u.eachItem)(N, (v) => Oe.call(this, v)), this;
      yt.call(this, D);
      const d = {
        ...D,
        type: (0, i.getJSONTypes)(D.type),
        schemaType: (0, i.getJSONTypes)(D.schemaType)
      };
      return (0, u.eachItem)(N, d.type.length === 0 ? (v) => Oe.call(this, v, d) : (v) => d.type.forEach((A) => Oe.call(this, v, d, A))), this;
    }
    getKeyword(P) {
      const D = this.RULES.all[P];
      return typeof D == "object" ? D.definition : !!D;
    }
    // Remove keyword
    removeKeyword(P) {
      const { RULES: D } = this;
      delete D.keywords[P], delete D.all[P];
      for (const N of D.rules) {
        const d = N.rules.findIndex((v) => v.keyword === P);
        d >= 0 && N.rules.splice(d, 1);
      }
      return this;
    }
    // Add format
    addFormat(P, D) {
      return typeof D == "string" && (D = new RegExp(D)), this.formats[P] = D, this;
    }
    errorsText(P = this.errors, { separator: D = ", ", dataVar: N = "data" } = {}) {
      return !P || P.length === 0 ? "No errors" : P.map((d) => `${N}${d.instancePath} ${d.message}`).reduce((d, v) => d + D + v);
    }
    $dataMetaSchema(P, D) {
      const N = this.RULES.all;
      P = JSON.parse(JSON.stringify(P));
      for (const d of D) {
        const v = d.split("/").slice(1);
        let A = P;
        for (const z of v)
          A = A[z];
        for (const z in N) {
          const V = N[z];
          if (typeof V != "object")
            continue;
          const { $data: Y } = V.definition, Z = A[z];
          Y && Z && (A[z] = gt(Z));
        }
      }
      return P;
    }
    _removeAllSchemas(P, D) {
      for (const N in P) {
        const d = P[N];
        (!D || D.test(N)) && (typeof d == "string" ? delete P[N] : d && !d.meta && (this._cache.delete(d.schema), delete P[N]));
      }
    }
    _addSchema(P, D, N, d = this.opts.validateSchema, v = this.opts.addUsedSchema) {
      let A;
      const { schemaId: z } = this.opts;
      if (typeof P == "object")
        A = P[z];
      else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        if (typeof P != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let V = this._cache.get(P);
      if (V !== void 0)
        return V;
      N = (0, f.normalizeId)(A || N);
      const Y = f.getSchemaRefs.call(this, P, N);
      return V = new a.SchemaEnv({ schema: P, schemaId: z, meta: D, baseId: N, localRefs: Y }), this._cache.set(V.schema, V), v && !N.startsWith("#") && (N && this._checkUnique(N), this.refs[N] = V), d && this.validateSchema(P, !0), V;
    }
    _checkUnique(P) {
      if (this.schemas[P] || this.refs[P])
        throw new Error(`schema with key or id "${P}" already exists`);
    }
    _compileSchemaEnv(P) {
      if (P.meta ? this._compileMetaSchema(P) : a.compileSchema.call(this, P), !P.validate)
        throw new Error("ajv implementation error");
      return P.validate;
    }
    _compileMetaSchema(P) {
      const D = this.opts;
      this.opts = this._metaOpts;
      try {
        a.compileSchema.call(this, P);
      } finally {
        this.opts = D;
      }
    }
  }
  e.default = j, j.ValidationError = n.default, j.MissingRefError = s.default;
  function k(U, P, D, N = "error") {
    for (const d in U) {
      const v = d;
      v in P && this.logger[N](`${D}: option ${d}. ${U[v]}`);
    }
  }
  function S(U) {
    return U = (0, f.normalizeId)(U), this.schemas[U] || this.refs[U];
  }
  function C() {
    const U = this.opts.schemas;
    if (U)
      if (Array.isArray(U))
        this.addSchema(U);
      else
        for (const P in U)
          this.addSchema(U[P], P);
  }
  function M() {
    for (const U in this.opts.formats) {
      const P = this.opts.formats[U];
      P && this.addFormat(U, P);
    }
  }
  function F(U) {
    if (Array.isArray(U)) {
      this.addVocabulary(U);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const P in U) {
      const D = U[P];
      D.keyword || (D.keyword = P), this.addKeyword(D);
    }
  }
  function L() {
    const U = { ...this.opts };
    for (const P of h)
      delete U[P];
    return U;
  }
  const x = { log() {
  }, warn() {
  }, error() {
  } };
  function B(U) {
    if (U === !1)
      return x;
    if (U === void 0)
      return console;
    if (U.log && U.warn && U.error)
      return U;
    throw new Error("logger must implement log, warn and error methods");
  }
  const pe = /^[a-z_$][a-z0-9_$:-]*$/i;
  function se(U, P) {
    const { RULES: D } = this;
    if ((0, u.eachItem)(U, (N) => {
      if (D.keywords[N])
        throw new Error(`Keyword ${N} is already defined`);
      if (!pe.test(N))
        throw new Error(`Keyword ${N} has invalid name`);
    }), !!P && P.$data && !("code" in P || "validate" in P))
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function Oe(U, P, D) {
    var N;
    const d = P == null ? void 0 : P.post;
    if (D && d)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: v } = this;
    let A = d ? v.post : v.rules.find(({ type: V }) => V === D);
    if (A || (A = { type: D, rules: [] }, v.rules.push(A)), v.keywords[U] = !0, !P)
      return;
    const z = {
      keyword: U,
      definition: {
        ...P,
        type: (0, i.getJSONTypes)(P.type),
        schemaType: (0, i.getJSONTypes)(P.schemaType)
      }
    };
    P.before ? ot.call(this, A, z, P.before) : A.rules.push(z), v.all[U] = z, (N = P.implements) === null || N === void 0 || N.forEach((V) => this.addKeyword(V));
  }
  function ot(U, P, D) {
    const N = U.rules.findIndex((d) => d.keyword === D);
    N >= 0 ? U.rules.splice(N, 0, P) : (U.rules.push(P), this.logger.warn(`rule ${D} is not defined`));
  }
  function yt(U) {
    let { metaSchema: P } = U;
    P !== void 0 && (U.$data && this.opts.$data && (P = gt(P)), U.validateSchema = this.compile(P, !0));
  }
  const Mt = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function gt(U) {
    return { anyOf: [U, Mt] };
  }
})(mo);
var Dn = {}, kn = {}, Mn = {};
Object.defineProperty(Mn, "__esModule", { value: !0 });
const Tc = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
Mn.default = Tc;
var mt = {};
Object.defineProperty(mt, "__esModule", { value: !0 });
mt.callRef = mt.getValidate = void 0;
const Rc = lr, Ms = X, Ee = W, Ot = Be, Fs = Se, vr = re, Cc = {
  keyword: "$ref",
  schemaType: "string",
  code(e) {
    const { gen: t, schema: r, it: n } = e, { baseId: s, schemaEnv: o, validateName: a, opts: c, self: f } = n, { root: i } = o;
    if ((r === "#" || r === "#/") && s === i.baseId)
      return l();
    const u = Fs.resolveRef.call(f, i, s, r);
    if (u === void 0)
      throw new Rc.default(n.opts.uriResolver, s, r);
    if (u instanceof Fs.SchemaEnv)
      return w(u);
    return b(u);
    function l() {
      if (o === i)
        return Sr(e, a, o, o.$async);
      const h = t.scopeValue("root", { ref: i });
      return Sr(e, (0, Ee._)`${h}.validate`, i, i.$async);
    }
    function w(h) {
      const y = Vo(e, h);
      Sr(e, y, h, h.$async);
    }
    function b(h) {
      const y = t.scopeValue("schema", c.code.source === !0 ? { ref: h, code: (0, Ee.stringify)(h) } : { ref: h }), _ = t.name("valid"), m = e.subschema({
        schema: h,
        dataTypes: [],
        schemaPath: Ee.nil,
        topSchemaRef: y,
        errSchemaPath: r
      }, _);
      e.mergeEvaluated(m), e.ok(_);
    }
  }
};
function Vo(e, t) {
  const { gen: r } = e;
  return t.validate ? r.scopeValue("validate", { ref: t.validate }) : (0, Ee._)`${r.scopeValue("wrapper", { ref: t })}.validate`;
}
mt.getValidate = Vo;
function Sr(e, t, r, n) {
  const { gen: s, it: o } = e, { allErrors: a, schemaEnv: c, opts: f } = o, i = f.passContext ? Ot.default.this : Ee.nil;
  n ? u() : l();
  function u() {
    if (!c.$async)
      throw new Error("async schema referenced by sync schema");
    const h = s.let("valid");
    s.try(() => {
      s.code((0, Ee._)`await ${(0, Ms.callValidateCode)(e, t, i)}`), b(t), a || s.assign(h, !0);
    }, (y) => {
      s.if((0, Ee._)`!(${y} instanceof ${o.ValidationError})`, () => s.throw(y)), w(y), a || s.assign(h, !1);
    }), e.ok(h);
  }
  function l() {
    e.result((0, Ms.callValidateCode)(e, t, i), () => b(t), () => w(t));
  }
  function w(h) {
    const y = (0, Ee._)`${h}.errors`;
    s.assign(Ot.default.vErrors, (0, Ee._)`${Ot.default.vErrors} === null ? ${y} : ${Ot.default.vErrors}.concat(${y})`), s.assign(Ot.default.errors, (0, Ee._)`${Ot.default.vErrors}.length`);
  }
  function b(h) {
    var y;
    if (!o.opts.unevaluated)
      return;
    const _ = (y = r == null ? void 0 : r.validate) === null || y === void 0 ? void 0 : y.evaluated;
    if (o.props !== !0)
      if (_ && !_.dynamicProps)
        _.props !== void 0 && (o.props = vr.mergeEvaluated.props(s, _.props, o.props));
      else {
        const m = s.var("props", (0, Ee._)`${h}.evaluated.props`);
        o.props = vr.mergeEvaluated.props(s, m, o.props, Ee.Name);
      }
    if (o.items !== !0)
      if (_ && !_.dynamicItems)
        _.items !== void 0 && (o.items = vr.mergeEvaluated.items(s, _.items, o.items));
      else {
        const m = s.var("items", (0, Ee._)`${h}.evaluated.items`);
        o.items = vr.mergeEvaluated.items(s, m, o.items, Ee.Name);
      }
  }
}
mt.callRef = Sr;
mt.default = Cc;
Object.defineProperty(kn, "__esModule", { value: !0 });
const jc = Mn, Ac = mt, Ic = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  jc.default,
  Ac.default
];
kn.default = Ic;
var Fn = {}, Un = {};
Object.defineProperty(Un, "__esModule", { value: !0 });
const Mr = W, tt = Mr.operators, Fr = {
  maximum: { okStr: "<=", ok: tt.LTE, fail: tt.GT },
  minimum: { okStr: ">=", ok: tt.GTE, fail: tt.LT },
  exclusiveMaximum: { okStr: "<", ok: tt.LT, fail: tt.GTE },
  exclusiveMinimum: { okStr: ">", ok: tt.GT, fail: tt.LTE }
}, Dc = {
  message: ({ keyword: e, schemaCode: t }) => (0, Mr.str)`must be ${Fr[e].okStr} ${t}`,
  params: ({ keyword: e, schemaCode: t }) => (0, Mr._)`{comparison: ${Fr[e].okStr}, limit: ${t}}`
}, kc = {
  keyword: Object.keys(Fr),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: Dc,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e;
    e.fail$data((0, Mr._)`${r} ${Fr[t].fail} ${n} || isNaN(${r})`);
  }
};
Un.default = kc;
var zn = {};
Object.defineProperty(zn, "__esModule", { value: !0 });
const Qt = W, Mc = {
  message: ({ schemaCode: e }) => (0, Qt.str)`must be multiple of ${e}`,
  params: ({ schemaCode: e }) => (0, Qt._)`{multipleOf: ${e}}`
}, Fc = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: !0,
  error: Mc,
  code(e) {
    const { gen: t, data: r, schemaCode: n, it: s } = e, o = s.opts.multipleOfPrecision, a = t.let("res"), c = o ? (0, Qt._)`Math.abs(Math.round(${a}) - ${a}) > 1e-${o}` : (0, Qt._)`${a} !== parseInt(${a})`;
    e.fail$data((0, Qt._)`(${n} === 0 || (${a} = ${r}/${n}, ${c}))`);
  }
};
zn.default = Fc;
var Vn = {}, Ln = {};
Object.defineProperty(Ln, "__esModule", { value: !0 });
function Lo(e) {
  const t = e.length;
  let r = 0, n = 0, s;
  for (; n < t; )
    r++, s = e.charCodeAt(n++), s >= 55296 && s <= 56319 && n < t && (s = e.charCodeAt(n), (s & 64512) === 56320 && n++);
  return r;
}
Ln.default = Lo;
Lo.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(Vn, "__esModule", { value: !0 });
const ft = W, Uc = re, zc = Ln, Vc = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxLength" ? "more" : "fewer";
    return (0, ft.str)`must NOT have ${r} than ${t} characters`;
  },
  params: ({ schemaCode: e }) => (0, ft._)`{limit: ${e}}`
}, Lc = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: !0,
  error: Vc,
  code(e) {
    const { keyword: t, data: r, schemaCode: n, it: s } = e, o = t === "maxLength" ? ft.operators.GT : ft.operators.LT, a = s.opts.unicode === !1 ? (0, ft._)`${r}.length` : (0, ft._)`${(0, Uc.useFunc)(e.gen, zc.default)}(${r})`;
    e.fail$data((0, ft._)`${a} ${o} ${n}`);
  }
};
Vn.default = Lc;
var qn = {};
Object.defineProperty(qn, "__esModule", { value: !0 });
const qc = X, Ur = W, Hc = {
  message: ({ schemaCode: e }) => (0, Ur.str)`must match pattern "${e}"`,
  params: ({ schemaCode: e }) => (0, Ur._)`{pattern: ${e}}`
}, Kc = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: !0,
  error: Hc,
  code(e) {
    const { data: t, $data: r, schema: n, schemaCode: s, it: o } = e, a = o.opts.unicodeRegExp ? "u" : "", c = r ? (0, Ur._)`(new RegExp(${s}, ${a}))` : (0, qc.usePattern)(e, n);
    e.fail$data((0, Ur._)`!${c}.test(${t})`);
  }
};
qn.default = Kc;
var Hn = {};
Object.defineProperty(Hn, "__esModule", { value: !0 });
const Zt = W, Bc = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxProperties" ? "more" : "fewer";
    return (0, Zt.str)`must NOT have ${r} than ${t} properties`;
  },
  params: ({ schemaCode: e }) => (0, Zt._)`{limit: ${e}}`
}, Gc = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: !0,
  error: Bc,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e, s = t === "maxProperties" ? Zt.operators.GT : Zt.operators.LT;
    e.fail$data((0, Zt._)`Object.keys(${r}).length ${s} ${n}`);
  }
};
Hn.default = Gc;
var Kn = {};
Object.defineProperty(Kn, "__esModule", { value: !0 });
const Jt = X, er = W, Jc = re, Wc = {
  message: ({ params: { missingProperty: e } }) => (0, er.str)`must have required property '${e}'`,
  params: ({ params: { missingProperty: e } }) => (0, er._)`{missingProperty: ${e}}`
}, xc = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: !0,
  error: Wc,
  code(e) {
    const { gen: t, schema: r, schemaCode: n, data: s, $data: o, it: a } = e, { opts: c } = a;
    if (!o && r.length === 0)
      return;
    const f = r.length >= c.loopRequired;
    if (a.allErrors ? i() : u(), c.strictRequired) {
      const b = e.parentSchema.properties, { definedProperties: h } = e.it;
      for (const y of r)
        if ((b == null ? void 0 : b[y]) === void 0 && !h.has(y)) {
          const _ = a.schemaEnv.baseId + a.errSchemaPath, m = `required property "${y}" is not defined at "${_}" (strictRequired)`;
          (0, Jc.checkStrictMode)(a, m, a.opts.strictRequired);
        }
    }
    function i() {
      if (f || o)
        e.block$data(er.nil, l);
      else
        for (const b of r)
          (0, Jt.checkReportMissingProp)(e, b);
    }
    function u() {
      const b = t.let("missing");
      if (f || o) {
        const h = t.let("valid", !0);
        e.block$data(h, () => w(b, h)), e.ok(h);
      } else
        t.if((0, Jt.checkMissingProp)(e, r, b)), (0, Jt.reportMissingProp)(e, b), t.else();
    }
    function l() {
      t.forOf("prop", n, (b) => {
        e.setParams({ missingProperty: b }), t.if((0, Jt.noPropertyInData)(t, s, b, c.ownProperties), () => e.error());
      });
    }
    function w(b, h) {
      e.setParams({ missingProperty: b }), t.forOf(b, n, () => {
        t.assign(h, (0, Jt.propertyInData)(t, s, b, c.ownProperties)), t.if((0, er.not)(h), () => {
          e.error(), t.break();
        });
      }, er.nil);
    }
  }
};
Kn.default = xc;
var Bn = {};
Object.defineProperty(Bn, "__esModule", { value: !0 });
const tr = W, Xc = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxItems" ? "more" : "fewer";
    return (0, tr.str)`must NOT have ${r} than ${t} items`;
  },
  params: ({ schemaCode: e }) => (0, tr._)`{limit: ${e}}`
}, Yc = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: !0,
  error: Xc,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e, s = t === "maxItems" ? tr.operators.GT : tr.operators.LT;
    e.fail$data((0, tr._)`${r}.length ${s} ${n}`);
  }
};
Bn.default = Yc;
var Gn = {}, dr = {};
Object.defineProperty(dr, "__esModule", { value: !0 });
const qo = Eo;
qo.code = 'require("ajv/dist/runtime/equal").default';
dr.default = qo;
Object.defineProperty(Gn, "__esModule", { value: !0 });
const sn = cr, ge = W, Qc = re, Zc = dr, eu = {
  message: ({ params: { i: e, j: t } }) => (0, ge.str)`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
  params: ({ params: { i: e, j: t } }) => (0, ge._)`{i: ${e}, j: ${t}}`
}, tu = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: !0,
  error: eu,
  code(e) {
    const { gen: t, data: r, $data: n, schema: s, parentSchema: o, schemaCode: a, it: c } = e;
    if (!n && !s)
      return;
    const f = t.let("valid"), i = o.items ? (0, sn.getSchemaTypes)(o.items) : [];
    e.block$data(f, u, (0, ge._)`${a} === false`), e.ok(f);
    function u() {
      const h = t.let("i", (0, ge._)`${r}.length`), y = t.let("j");
      e.setParams({ i: h, j: y }), t.assign(f, !0), t.if((0, ge._)`${h} > 1`, () => (l() ? w : b)(h, y));
    }
    function l() {
      return i.length > 0 && !i.some((h) => h === "object" || h === "array");
    }
    function w(h, y) {
      const _ = t.name("item"), m = (0, sn.checkDataTypes)(i, _, c.opts.strictNumbers, sn.DataType.Wrong), E = t.const("indices", (0, ge._)`{}`);
      t.for((0, ge._)`;${h}--;`, () => {
        t.let(_, (0, ge._)`${r}[${h}]`), t.if(m, (0, ge._)`continue`), i.length > 1 && t.if((0, ge._)`typeof ${_} == "string"`, (0, ge._)`${_} += "_"`), t.if((0, ge._)`typeof ${E}[${_}] == "number"`, () => {
          t.assign(y, (0, ge._)`${E}[${_}]`), e.error(), t.assign(f, !1).break();
        }).code((0, ge._)`${E}[${_}] = ${h}`);
      });
    }
    function b(h, y) {
      const _ = (0, Qc.useFunc)(t, Zc.default), m = t.name("outer");
      t.label(m).for((0, ge._)`;${h}--;`, () => t.for((0, ge._)`${y} = ${h}; ${y}--;`, () => t.if((0, ge._)`${_}(${r}[${h}], ${r}[${y}])`, () => {
        e.error(), t.assign(f, !1).break(m);
      })));
    }
  }
};
Gn.default = tu;
var Jn = {};
Object.defineProperty(Jn, "__esModule", { value: !0 });
const vn = W, ru = re, nu = dr, su = {
  message: "must be equal to constant",
  params: ({ schemaCode: e }) => (0, vn._)`{allowedValue: ${e}}`
}, ou = {
  keyword: "const",
  $data: !0,
  error: su,
  code(e) {
    const { gen: t, data: r, $data: n, schemaCode: s, schema: o } = e;
    n || o && typeof o == "object" ? e.fail$data((0, vn._)`!${(0, ru.useFunc)(t, nu.default)}(${r}, ${s})`) : e.fail((0, vn._)`${o} !== ${r}`);
  }
};
Jn.default = ou;
var Wn = {};
Object.defineProperty(Wn, "__esModule", { value: !0 });
const Xt = W, au = re, iu = dr, cu = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: e }) => (0, Xt._)`{allowedValues: ${e}}`
}, uu = {
  keyword: "enum",
  schemaType: "array",
  $data: !0,
  error: cu,
  code(e) {
    const { gen: t, data: r, $data: n, schema: s, schemaCode: o, it: a } = e;
    if (!n && s.length === 0)
      throw new Error("enum must have non-empty array");
    const c = s.length >= a.opts.loopEnum;
    let f;
    const i = () => f ?? (f = (0, au.useFunc)(t, iu.default));
    let u;
    if (c || n)
      u = t.let("valid"), e.block$data(u, l);
    else {
      if (!Array.isArray(s))
        throw new Error("ajv implementation error");
      const b = t.const("vSchema", o);
      u = (0, Xt.or)(...s.map((h, y) => w(b, y)));
    }
    e.pass(u);
    function l() {
      t.assign(u, !1), t.forOf("v", o, (b) => t.if((0, Xt._)`${i()}(${r}, ${b})`, () => t.assign(u, !0).break()));
    }
    function w(b, h) {
      const y = s[h];
      return typeof y == "object" && y !== null ? (0, Xt._)`${i()}(${r}, ${b}[${h}])` : (0, Xt._)`${r} === ${y}`;
    }
  }
};
Wn.default = uu;
Object.defineProperty(Fn, "__esModule", { value: !0 });
const lu = Un, du = zn, fu = Vn, pu = qn, hu = Hn, mu = Kn, yu = Bn, gu = Gn, vu = Jn, $u = Wn, _u = [
  // number
  lu.default,
  du.default,
  // string
  fu.default,
  pu.default,
  // object
  hu.default,
  mu.default,
  // array
  yu.default,
  gu.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  vu.default,
  $u.default
];
Fn.default = _u;
var xn = {}, It = {};
Object.defineProperty(It, "__esModule", { value: !0 });
It.validateAdditionalItems = void 0;
const pt = W, $n = re, wu = {
  message: ({ params: { len: e } }) => (0, pt.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, pt._)`{limit: ${e}}`
}, bu = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: wu,
  code(e) {
    const { parentSchema: t, it: r } = e, { items: n } = t;
    if (!Array.isArray(n)) {
      (0, $n.checkStrictMode)(r, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    Ho(e, n);
  }
};
function Ho(e, t) {
  const { gen: r, schema: n, data: s, keyword: o, it: a } = e;
  a.items = !0;
  const c = r.const("len", (0, pt._)`${s}.length`);
  if (n === !1)
    e.setParams({ len: t.length }), e.pass((0, pt._)`${c} <= ${t.length}`);
  else if (typeof n == "object" && !(0, $n.alwaysValidSchema)(a, n)) {
    const i = r.var("valid", (0, pt._)`${c} <= ${t.length}`);
    r.if((0, pt.not)(i), () => f(i)), e.ok(i);
  }
  function f(i) {
    r.forRange("i", t.length, c, (u) => {
      e.subschema({ keyword: o, dataProp: u, dataPropType: $n.Type.Num }, i), a.allErrors || r.if((0, pt.not)(i), () => r.break());
    });
  }
}
It.validateAdditionalItems = Ho;
It.default = bu;
var Xn = {}, Dt = {};
Object.defineProperty(Dt, "__esModule", { value: !0 });
Dt.validateTuple = void 0;
const Us = W, Pr = re, Eu = X, Su = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(e) {
    const { schema: t, it: r } = e;
    if (Array.isArray(t))
      return Ko(e, "additionalItems", t);
    r.items = !0, !(0, Pr.alwaysValidSchema)(r, t) && e.ok((0, Eu.validateArray)(e));
  }
};
function Ko(e, t, r = e.schema) {
  const { gen: n, parentSchema: s, data: o, keyword: a, it: c } = e;
  u(s), c.opts.unevaluated && r.length && c.items !== !0 && (c.items = Pr.mergeEvaluated.items(n, r.length, c.items));
  const f = n.name("valid"), i = n.const("len", (0, Us._)`${o}.length`);
  r.forEach((l, w) => {
    (0, Pr.alwaysValidSchema)(c, l) || (n.if((0, Us._)`${i} > ${w}`, () => e.subschema({
      keyword: a,
      schemaProp: w,
      dataProp: w
    }, f)), e.ok(f));
  });
  function u(l) {
    const { opts: w, errSchemaPath: b } = c, h = r.length, y = h === l.minItems && (h === l.maxItems || l[t] === !1);
    if (w.strictTuples && !y) {
      const _ = `"${a}" is ${h}-tuple, but minItems or maxItems/${t} are not specified or different at path "${b}"`;
      (0, Pr.checkStrictMode)(c, _, w.strictTuples);
    }
  }
}
Dt.validateTuple = Ko;
Dt.default = Su;
Object.defineProperty(Xn, "__esModule", { value: !0 });
const Pu = Dt, Ou = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (e) => (0, Pu.validateTuple)(e, "items")
};
Xn.default = Ou;
var Yn = {};
Object.defineProperty(Yn, "__esModule", { value: !0 });
const zs = W, Nu = re, Tu = X, Ru = It, Cu = {
  message: ({ params: { len: e } }) => (0, zs.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, zs._)`{limit: ${e}}`
}, ju = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: Cu,
  code(e) {
    const { schema: t, parentSchema: r, it: n } = e, { prefixItems: s } = r;
    n.items = !0, !(0, Nu.alwaysValidSchema)(n, t) && (s ? (0, Ru.validateAdditionalItems)(e, s) : e.ok((0, Tu.validateArray)(e)));
  }
};
Yn.default = ju;
var Qn = {};
Object.defineProperty(Qn, "__esModule", { value: !0 });
const Re = W, $r = re, Au = {
  message: ({ params: { min: e, max: t } }) => t === void 0 ? (0, Re.str)`must contain at least ${e} valid item(s)` : (0, Re.str)`must contain at least ${e} and no more than ${t} valid item(s)`,
  params: ({ params: { min: e, max: t } }) => t === void 0 ? (0, Re._)`{minContains: ${e}}` : (0, Re._)`{minContains: ${e}, maxContains: ${t}}`
}, Iu = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: !0,
  error: Au,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: s, it: o } = e;
    let a, c;
    const { minContains: f, maxContains: i } = n;
    o.opts.next ? (a = f === void 0 ? 1 : f, c = i) : a = 1;
    const u = t.const("len", (0, Re._)`${s}.length`);
    if (e.setParams({ min: a, max: c }), c === void 0 && a === 0) {
      (0, $r.checkStrictMode)(o, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (c !== void 0 && a > c) {
      (0, $r.checkStrictMode)(o, '"minContains" > "maxContains" is always invalid'), e.fail();
      return;
    }
    if ((0, $r.alwaysValidSchema)(o, r)) {
      let y = (0, Re._)`${u} >= ${a}`;
      c !== void 0 && (y = (0, Re._)`${y} && ${u} <= ${c}`), e.pass(y);
      return;
    }
    o.items = !0;
    const l = t.name("valid");
    c === void 0 && a === 1 ? b(l, () => t.if(l, () => t.break())) : a === 0 ? (t.let(l, !0), c !== void 0 && t.if((0, Re._)`${s}.length > 0`, w)) : (t.let(l, !1), w()), e.result(l, () => e.reset());
    function w() {
      const y = t.name("_valid"), _ = t.let("count", 0);
      b(y, () => t.if(y, () => h(_)));
    }
    function b(y, _) {
      t.forRange("i", 0, u, (m) => {
        e.subschema({
          keyword: "contains",
          dataProp: m,
          dataPropType: $r.Type.Num,
          compositeRule: !0
        }, y), _();
      });
    }
    function h(y) {
      t.code((0, Re._)`${y}++`), c === void 0 ? t.if((0, Re._)`${y} >= ${a}`, () => t.assign(l, !0).break()) : (t.if((0, Re._)`${y} > ${c}`, () => t.assign(l, !1).break()), a === 1 ? t.assign(l, !0) : t.if((0, Re._)`${y} >= ${a}`, () => t.assign(l, !0)));
    }
  }
};
Qn.default = Iu;
var Bo = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
  const t = W, r = re, n = X;
  e.error = {
    message: ({ params: { property: f, depsCount: i, deps: u } }) => {
      const l = i === 1 ? "property" : "properties";
      return (0, t.str)`must have ${l} ${u} when property ${f} is present`;
    },
    params: ({ params: { property: f, depsCount: i, deps: u, missingProperty: l } }) => (0, t._)`{property: ${f},
    missingProperty: ${l},
    depsCount: ${i},
    deps: ${u}}`
    // TODO change to reference
  };
  const s = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: e.error,
    code(f) {
      const [i, u] = o(f);
      a(f, i), c(f, u);
    }
  };
  function o({ schema: f }) {
    const i = {}, u = {};
    for (const l in f) {
      if (l === "__proto__")
        continue;
      const w = Array.isArray(f[l]) ? i : u;
      w[l] = f[l];
    }
    return [i, u];
  }
  function a(f, i = f.schema) {
    const { gen: u, data: l, it: w } = f;
    if (Object.keys(i).length === 0)
      return;
    const b = u.let("missing");
    for (const h in i) {
      const y = i[h];
      if (y.length === 0)
        continue;
      const _ = (0, n.propertyInData)(u, l, h, w.opts.ownProperties);
      f.setParams({
        property: h,
        depsCount: y.length,
        deps: y.join(", ")
      }), w.allErrors ? u.if(_, () => {
        for (const m of y)
          (0, n.checkReportMissingProp)(f, m);
      }) : (u.if((0, t._)`${_} && (${(0, n.checkMissingProp)(f, y, b)})`), (0, n.reportMissingProp)(f, b), u.else());
    }
  }
  e.validatePropertyDeps = a;
  function c(f, i = f.schema) {
    const { gen: u, data: l, keyword: w, it: b } = f, h = u.name("valid");
    for (const y in i)
      (0, r.alwaysValidSchema)(b, i[y]) || (u.if(
        (0, n.propertyInData)(u, l, y, b.opts.ownProperties),
        () => {
          const _ = f.subschema({ keyword: w, schemaProp: y }, h);
          f.mergeValidEvaluated(_, h);
        },
        () => u.var(h, !0)
        // TODO var
      ), f.ok(h));
  }
  e.validateSchemaDeps = c, e.default = s;
})(Bo);
var Zn = {};
Object.defineProperty(Zn, "__esModule", { value: !0 });
const Go = W, Du = re, ku = {
  message: "property name must be valid",
  params: ({ params: e }) => (0, Go._)`{propertyName: ${e.propertyName}}`
}, Mu = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: ku,
  code(e) {
    const { gen: t, schema: r, data: n, it: s } = e;
    if ((0, Du.alwaysValidSchema)(s, r))
      return;
    const o = t.name("valid");
    t.forIn("key", n, (a) => {
      e.setParams({ propertyName: a }), e.subschema({
        keyword: "propertyNames",
        data: a,
        dataTypes: ["string"],
        propertyName: a,
        compositeRule: !0
      }, o), t.if((0, Go.not)(o), () => {
        e.error(!0), s.allErrors || t.break();
      });
    }), e.ok(o);
  }
};
Zn.default = Mu;
var Jr = {};
Object.defineProperty(Jr, "__esModule", { value: !0 });
const _r = X, je = W, Fu = Be, wr = re, Uu = {
  message: "must NOT have additional properties",
  params: ({ params: e }) => (0, je._)`{additionalProperty: ${e.additionalProperty}}`
}, zu = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: !0,
  trackErrors: !0,
  error: Uu,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: s, errsCount: o, it: a } = e;
    if (!o)
      throw new Error("ajv implementation error");
    const { allErrors: c, opts: f } = a;
    if (a.props = !0, f.removeAdditional !== "all" && (0, wr.alwaysValidSchema)(a, r))
      return;
    const i = (0, _r.allSchemaProperties)(n.properties), u = (0, _r.allSchemaProperties)(n.patternProperties);
    l(), e.ok((0, je._)`${o} === ${Fu.default.errors}`);
    function l() {
      t.forIn("key", s, (_) => {
        !i.length && !u.length ? h(_) : t.if(w(_), () => h(_));
      });
    }
    function w(_) {
      let m;
      if (i.length > 8) {
        const E = (0, wr.schemaRefOrVal)(a, n.properties, "properties");
        m = (0, _r.isOwnProperty)(t, E, _);
      } else
        i.length ? m = (0, je.or)(...i.map((E) => (0, je._)`${_} === ${E}`)) : m = je.nil;
      return u.length && (m = (0, je.or)(m, ...u.map((E) => (0, je._)`${(0, _r.usePattern)(e, E)}.test(${_})`))), (0, je.not)(m);
    }
    function b(_) {
      t.code((0, je._)`delete ${s}[${_}]`);
    }
    function h(_) {
      if (f.removeAdditional === "all" || f.removeAdditional && r === !1) {
        b(_);
        return;
      }
      if (r === !1) {
        e.setParams({ additionalProperty: _ }), e.error(), c || t.break();
        return;
      }
      if (typeof r == "object" && !(0, wr.alwaysValidSchema)(a, r)) {
        const m = t.name("valid");
        f.removeAdditional === "failing" ? (y(_, m, !1), t.if((0, je.not)(m), () => {
          e.reset(), b(_);
        })) : (y(_, m), c || t.if((0, je.not)(m), () => t.break()));
      }
    }
    function y(_, m, E) {
      const O = {
        keyword: "additionalProperties",
        dataProp: _,
        dataPropType: wr.Type.Str
      };
      E === !1 && Object.assign(O, {
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }), e.subschema(O, m);
    }
  }
};
Jr.default = zu;
var es = {};
Object.defineProperty(es, "__esModule", { value: !0 });
const Vu = Ie, Vs = X, on = re, Ls = Jr, Lu = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: s, it: o } = e;
    o.opts.removeAdditional === "all" && n.additionalProperties === void 0 && Ls.default.code(new Vu.KeywordCxt(o, Ls.default, "additionalProperties"));
    const a = (0, Vs.allSchemaProperties)(r);
    for (const l of a)
      o.definedProperties.add(l);
    o.opts.unevaluated && a.length && o.props !== !0 && (o.props = on.mergeEvaluated.props(t, (0, on.toHash)(a), o.props));
    const c = a.filter((l) => !(0, on.alwaysValidSchema)(o, r[l]));
    if (c.length === 0)
      return;
    const f = t.name("valid");
    for (const l of c)
      i(l) ? u(l) : (t.if((0, Vs.propertyInData)(t, s, l, o.opts.ownProperties)), u(l), o.allErrors || t.else().var(f, !0), t.endIf()), e.it.definedProperties.add(l), e.ok(f);
    function i(l) {
      return o.opts.useDefaults && !o.compositeRule && r[l].default !== void 0;
    }
    function u(l) {
      e.subschema({
        keyword: "properties",
        schemaProp: l,
        dataProp: l
      }, f);
    }
  }
};
es.default = Lu;
var ts = {};
Object.defineProperty(ts, "__esModule", { value: !0 });
const qs = X, br = W, Hs = re, Ks = re, qu = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(e) {
    const { gen: t, schema: r, data: n, parentSchema: s, it: o } = e, { opts: a } = o, c = (0, qs.allSchemaProperties)(r), f = c.filter((y) => (0, Hs.alwaysValidSchema)(o, r[y]));
    if (c.length === 0 || f.length === c.length && (!o.opts.unevaluated || o.props === !0))
      return;
    const i = a.strictSchema && !a.allowMatchingProperties && s.properties, u = t.name("valid");
    o.props !== !0 && !(o.props instanceof br.Name) && (o.props = (0, Ks.evaluatedPropsToName)(t, o.props));
    const { props: l } = o;
    w();
    function w() {
      for (const y of c)
        i && b(y), o.allErrors ? h(y) : (t.var(u, !0), h(y), t.if(u));
    }
    function b(y) {
      for (const _ in i)
        new RegExp(y).test(_) && (0, Hs.checkStrictMode)(o, `property ${_} matches pattern ${y} (use allowMatchingProperties)`);
    }
    function h(y) {
      t.forIn("key", n, (_) => {
        t.if((0, br._)`${(0, qs.usePattern)(e, y)}.test(${_})`, () => {
          const m = f.includes(y);
          m || e.subschema({
            keyword: "patternProperties",
            schemaProp: y,
            dataProp: _,
            dataPropType: Ks.Type.Str
          }, u), o.opts.unevaluated && l !== !0 ? t.assign((0, br._)`${l}[${_}]`, !0) : !m && !o.allErrors && t.if((0, br.not)(u), () => t.break());
        });
      });
    }
  }
};
ts.default = qu;
var rs = {};
Object.defineProperty(rs, "__esModule", { value: !0 });
const Hu = re, Ku = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  code(e) {
    const { gen: t, schema: r, it: n } = e;
    if ((0, Hu.alwaysValidSchema)(n, r)) {
      e.fail();
      return;
    }
    const s = t.name("valid");
    e.subschema({
      keyword: "not",
      compositeRule: !0,
      createErrors: !1,
      allErrors: !1
    }, s), e.failResult(s, () => e.reset(), () => e.error());
  },
  error: { message: "must NOT be valid" }
};
rs.default = Ku;
var ns = {};
Object.defineProperty(ns, "__esModule", { value: !0 });
const Bu = X, Gu = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: !0,
  code: Bu.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
ns.default = Gu;
var ss = {};
Object.defineProperty(ss, "__esModule", { value: !0 });
const Or = W, Ju = re, Wu = {
  message: "must match exactly one schema in oneOf",
  params: ({ params: e }) => (0, Or._)`{passingSchemas: ${e.passing}}`
}, xu = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: !0,
  error: Wu,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, it: s } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    if (s.opts.discriminator && n.discriminator)
      return;
    const o = r, a = t.let("valid", !1), c = t.let("passing", null), f = t.name("_valid");
    e.setParams({ passing: c }), t.block(i), e.result(a, () => e.reset(), () => e.error(!0));
    function i() {
      o.forEach((u, l) => {
        let w;
        (0, Ju.alwaysValidSchema)(s, u) ? t.var(f, !0) : w = e.subschema({
          keyword: "oneOf",
          schemaProp: l,
          compositeRule: !0
        }, f), l > 0 && t.if((0, Or._)`${f} && ${a}`).assign(a, !1).assign(c, (0, Or._)`[${c}, ${l}]`).else(), t.if(f, () => {
          t.assign(a, !0), t.assign(c, l), w && e.mergeEvaluated(w, Or.Name);
        });
      });
    }
  }
};
ss.default = xu;
var os = {};
Object.defineProperty(os, "__esModule", { value: !0 });
const Xu = re, Yu = {
  keyword: "allOf",
  schemaType: "array",
  code(e) {
    const { gen: t, schema: r, it: n } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    const s = t.name("valid");
    r.forEach((o, a) => {
      if ((0, Xu.alwaysValidSchema)(n, o))
        return;
      const c = e.subschema({ keyword: "allOf", schemaProp: a }, s);
      e.ok(s), e.mergeEvaluated(c);
    });
  }
};
os.default = Yu;
var as = {};
Object.defineProperty(as, "__esModule", { value: !0 });
const zr = W, Jo = re, Qu = {
  message: ({ params: e }) => (0, zr.str)`must match "${e.ifClause}" schema`,
  params: ({ params: e }) => (0, zr._)`{failingKeyword: ${e.ifClause}}`
}, Zu = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  error: Qu,
  code(e) {
    const { gen: t, parentSchema: r, it: n } = e;
    r.then === void 0 && r.else === void 0 && (0, Jo.checkStrictMode)(n, '"if" without "then" and "else" is ignored');
    const s = Bs(n, "then"), o = Bs(n, "else");
    if (!s && !o)
      return;
    const a = t.let("valid", !0), c = t.name("_valid");
    if (f(), e.reset(), s && o) {
      const u = t.let("ifClause");
      e.setParams({ ifClause: u }), t.if(c, i("then", u), i("else", u));
    } else
      s ? t.if(c, i("then")) : t.if((0, zr.not)(c), i("else"));
    e.pass(a, () => e.error(!0));
    function f() {
      const u = e.subschema({
        keyword: "if",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, c);
      e.mergeEvaluated(u);
    }
    function i(u, l) {
      return () => {
        const w = e.subschema({ keyword: u }, c);
        t.assign(a, c), e.mergeValidEvaluated(w, a), l ? t.assign(l, (0, zr._)`${u}`) : e.setParams({ ifClause: u });
      };
    }
  }
};
function Bs(e, t) {
  const r = e.schema[t];
  return r !== void 0 && !(0, Jo.alwaysValidSchema)(e, r);
}
as.default = Zu;
var is = {};
Object.defineProperty(is, "__esModule", { value: !0 });
const el = re, tl = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: e, parentSchema: t, it: r }) {
    t.if === void 0 && (0, el.checkStrictMode)(r, `"${e}" without "if" is ignored`);
  }
};
is.default = tl;
Object.defineProperty(xn, "__esModule", { value: !0 });
const rl = It, nl = Xn, sl = Dt, ol = Yn, al = Qn, il = Bo, cl = Zn, ul = Jr, ll = es, dl = ts, fl = rs, pl = ns, hl = ss, ml = os, yl = as, gl = is;
function vl(e = !1) {
  const t = [
    // any
    fl.default,
    pl.default,
    hl.default,
    ml.default,
    yl.default,
    gl.default,
    // object
    cl.default,
    ul.default,
    il.default,
    ll.default,
    dl.default
  ];
  return e ? t.push(nl.default, ol.default) : t.push(rl.default, sl.default), t.push(al.default), t;
}
xn.default = vl;
var cs = {}, us = {};
Object.defineProperty(us, "__esModule", { value: !0 });
const fe = W, $l = {
  message: ({ schemaCode: e }) => (0, fe.str)`must match format "${e}"`,
  params: ({ schemaCode: e }) => (0, fe._)`{format: ${e}}`
}, _l = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: !0,
  error: $l,
  code(e, t) {
    const { gen: r, data: n, $data: s, schema: o, schemaCode: a, it: c } = e, { opts: f, errSchemaPath: i, schemaEnv: u, self: l } = c;
    if (!f.validateFormats)
      return;
    s ? w() : b();
    function w() {
      const h = r.scopeValue("formats", {
        ref: l.formats,
        code: f.code.formats
      }), y = r.const("fDef", (0, fe._)`${h}[${a}]`), _ = r.let("fType"), m = r.let("format");
      r.if((0, fe._)`typeof ${y} == "object" && !(${y} instanceof RegExp)`, () => r.assign(_, (0, fe._)`${y}.type || "string"`).assign(m, (0, fe._)`${y}.validate`), () => r.assign(_, (0, fe._)`"string"`).assign(m, y)), e.fail$data((0, fe.or)(E(), O()));
      function E() {
        return f.strictSchema === !1 ? fe.nil : (0, fe._)`${a} && !${m}`;
      }
      function O() {
        const j = u.$async ? (0, fe._)`(${y}.async ? await ${m}(${n}) : ${m}(${n}))` : (0, fe._)`${m}(${n})`, k = (0, fe._)`(typeof ${m} == "function" ? ${j} : ${m}.test(${n}))`;
        return (0, fe._)`${m} && ${m} !== true && ${_} === ${t} && !${k}`;
      }
    }
    function b() {
      const h = l.formats[o];
      if (!h) {
        E();
        return;
      }
      if (h === !0)
        return;
      const [y, _, m] = O(h);
      y === t && e.pass(j());
      function E() {
        if (f.strictSchema === !1) {
          l.logger.warn(k());
          return;
        }
        throw new Error(k());
        function k() {
          return `unknown format "${o}" ignored in schema at path "${i}"`;
        }
      }
      function O(k) {
        const S = k instanceof RegExp ? (0, fe.regexpCode)(k) : f.code.formats ? (0, fe._)`${f.code.formats}${(0, fe.getProperty)(o)}` : void 0, C = r.scopeValue("formats", { key: o, ref: k, code: S });
        return typeof k == "object" && !(k instanceof RegExp) ? [k.type || "string", k.validate, (0, fe._)`${C}.validate`] : ["string", k, C];
      }
      function j() {
        if (typeof h == "object" && !(h instanceof RegExp) && h.async) {
          if (!u.$async)
            throw new Error("async format in sync schema");
          return (0, fe._)`await ${m}(${n})`;
        }
        return typeof _ == "function" ? (0, fe._)`${m}(${n})` : (0, fe._)`${m}.test(${n})`;
      }
    }
  }
};
us.default = _l;
Object.defineProperty(cs, "__esModule", { value: !0 });
const wl = us, bl = [wl.default];
cs.default = bl;
var jt = {};
Object.defineProperty(jt, "__esModule", { value: !0 });
jt.contentVocabulary = jt.metadataVocabulary = void 0;
jt.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
jt.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(Dn, "__esModule", { value: !0 });
const El = kn, Sl = Fn, Pl = xn, Ol = cs, Gs = jt, Nl = [
  El.default,
  Sl.default,
  (0, Pl.default)(),
  Ol.default,
  Gs.metadataVocabulary,
  Gs.contentVocabulary
];
Dn.default = Nl;
var ls = {}, Wo = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DiscrError = void 0, function(t) {
    t.Tag = "tag", t.Mapping = "mapping";
  }(e.DiscrError || (e.DiscrError = {}));
})(Wo);
Object.defineProperty(ls, "__esModule", { value: !0 });
const Nt = W, _n = Wo, Js = Se, Tl = re, Rl = {
  message: ({ params: { discrError: e, tagName: t } }) => e === _n.DiscrError.Tag ? `tag "${t}" must be string` : `value of tag "${t}" must be in oneOf`,
  params: ({ params: { discrError: e, tag: t, tagName: r } }) => (0, Nt._)`{error: ${e}, tag: ${r}, tagValue: ${t}}`
}, Cl = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: Rl,
  code(e) {
    const { gen: t, data: r, schema: n, parentSchema: s, it: o } = e, { oneOf: a } = s;
    if (!o.opts.discriminator)
      throw new Error("discriminator: requires discriminator option");
    const c = n.propertyName;
    if (typeof c != "string")
      throw new Error("discriminator: requires propertyName");
    if (n.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!a)
      throw new Error("discriminator: requires oneOf keyword");
    const f = t.let("valid", !1), i = t.const("tag", (0, Nt._)`${r}${(0, Nt.getProperty)(c)}`);
    t.if((0, Nt._)`typeof ${i} == "string"`, () => u(), () => e.error(!1, { discrError: _n.DiscrError.Tag, tag: i, tagName: c })), e.ok(f);
    function u() {
      const b = w();
      t.if(!1);
      for (const h in b)
        t.elseIf((0, Nt._)`${i} === ${h}`), t.assign(f, l(b[h]));
      t.else(), e.error(!1, { discrError: _n.DiscrError.Mapping, tag: i, tagName: c }), t.endIf();
    }
    function l(b) {
      const h = t.name("valid"), y = e.subschema({ keyword: "oneOf", schemaProp: b }, h);
      return e.mergeEvaluated(y, Nt.Name), h;
    }
    function w() {
      var b;
      const h = {}, y = m(s);
      let _ = !0;
      for (let j = 0; j < a.length; j++) {
        let k = a[j];
        k != null && k.$ref && !(0, Tl.schemaHasRulesButRef)(k, o.self.RULES) && (k = Js.resolveRef.call(o.self, o.schemaEnv.root, o.baseId, k == null ? void 0 : k.$ref), k instanceof Js.SchemaEnv && (k = k.schema));
        const S = (b = k == null ? void 0 : k.properties) === null || b === void 0 ? void 0 : b[c];
        if (typeof S != "object")
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${c}"`);
        _ = _ && (y || m(k)), E(S, j);
      }
      if (!_)
        throw new Error(`discriminator: "${c}" must be required`);
      return h;
      function m({ required: j }) {
        return Array.isArray(j) && j.includes(c);
      }
      function E(j, k) {
        if (j.const)
          O(j.const, k);
        else if (j.enum)
          for (const S of j.enum)
            O(S, k);
        else
          throw new Error(`discriminator: "properties/${c}" must have "const" or "enum"`);
      }
      function O(j, k) {
        if (typeof j != "string" || j in h)
          throw new Error(`discriminator: "${c}" values must be unique strings`);
        h[j] = k;
      }
    }
  }
};
ls.default = Cl;
const jl = "http://json-schema.org/draft-07/schema#", Al = "http://json-schema.org/draft-07/schema#", Il = "Core schema meta-schema", Dl = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, kl = [
  "object",
  "boolean"
], Ml = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  readOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: !0
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  const: !0,
  enum: {
    type: "array",
    items: !0,
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  if: {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  else: {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, Fl = {
  $schema: jl,
  $id: Al,
  title: Il,
  definitions: Dl,
  type: kl,
  properties: Ml,
  default: !0
};
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
  const r = mo, n = Dn, s = ls, o = Fl, a = ["/properties"], c = "http://json-schema.org/draft-07/schema";
  class f extends r.default {
    _addVocabularies() {
      super._addVocabularies(), n.default.forEach((h) => this.addVocabulary(h)), this.opts.discriminator && this.addKeyword(s.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta)
        return;
      const h = this.opts.$data ? this.$dataMetaSchema(o, a) : o;
      this.addMetaSchema(h, c, !1), this.refs["http://json-schema.org/schema"] = c;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(c) ? c : void 0);
    }
  }
  e.exports = t = f, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = f;
  var i = Ie;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return i.KeywordCxt;
  } });
  var u = W;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return u._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return u.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return u.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return u.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return u.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
    return u.CodeGen;
  } });
  var l = ur;
  Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
    return l.default;
  } });
  var w = lr;
  Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
    return w.default;
  } });
})(Ja, rr);
const Ws = /* @__PURE__ */ ho(rr);
var Vr = {}, Ul = {
  get exports() {
    return Vr;
  },
  set exports(e) {
    Vr = e;
  }
}, xo = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.formatNames = e.fastFormats = e.fullFormats = void 0;
  function t(F, L) {
    return { validate: F, compare: L };
  }
  e.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: t(o, a),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: t(f, i),
    "date-time": t(l, w),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: y,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex: M,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte: m,
    // signed 32 bit integer
    int32: { type: "number", validate: j },
    // signed 64 bit integer
    int64: { type: "number", validate: k },
    // C-type float
    float: { type: "number", validate: S },
    // C-type double
    double: { type: "number", validate: S },
    // hint to the UI to hide input strings
    password: !0,
    // unchecked string payload
    binary: !0
  }, e.fastFormats = {
    ...e.fullFormats,
    date: t(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, a),
    time: t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, i),
    "date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, w),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  }, e.formatNames = Object.keys(e.fullFormats);
  function r(F) {
    return F % 4 === 0 && (F % 100 !== 0 || F % 400 === 0);
  }
  const n = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, s = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function o(F) {
    const L = n.exec(F);
    if (!L)
      return !1;
    const x = +L[1], B = +L[2], pe = +L[3];
    return B >= 1 && B <= 12 && pe >= 1 && pe <= (B === 2 && r(x) ? 29 : s[B]);
  }
  function a(F, L) {
    if (F && L)
      return F > L ? 1 : F < L ? -1 : 0;
  }
  const c = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  function f(F, L) {
    const x = c.exec(F);
    if (!x)
      return !1;
    const B = +x[1], pe = +x[2], se = +x[3], Oe = x[5];
    return (B <= 23 && pe <= 59 && se <= 59 || B === 23 && pe === 59 && se === 60) && (!L || Oe !== "");
  }
  function i(F, L) {
    if (!(F && L))
      return;
    const x = c.exec(F), B = c.exec(L);
    if (x && B)
      return F = x[1] + x[2] + x[3] + (x[4] || ""), L = B[1] + B[2] + B[3] + (B[4] || ""), F > L ? 1 : F < L ? -1 : 0;
  }
  const u = /t|\s/i;
  function l(F) {
    const L = F.split(u);
    return L.length === 2 && o(L[0]) && f(L[1], !0);
  }
  function w(F, L) {
    if (!(F && L))
      return;
    const [x, B] = F.split(u), [pe, se] = L.split(u), Oe = a(x, pe);
    if (Oe !== void 0)
      return Oe || i(B, se);
  }
  const b = /\/|:/, h = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function y(F) {
    return b.test(F) && h.test(F);
  }
  const _ = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function m(F) {
    return _.lastIndex = 0, _.test(F);
  }
  const E = -(2 ** 31), O = 2 ** 31 - 1;
  function j(F) {
    return Number.isInteger(F) && F <= O && F >= E;
  }
  function k(F) {
    return Number.isInteger(F);
  }
  function S() {
    return !0;
  }
  const C = /[^\\]\\Z/;
  function M(F) {
    if (C.test(F))
      return !1;
    try {
      return new RegExp(F), !0;
    } catch {
      return !1;
    }
  }
})(xo);
var Xo = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.formatLimitDefinition = void 0;
  const t = rr, r = W, n = r.operators, s = {
    formatMaximum: { okStr: "<=", ok: n.LTE, fail: n.GT },
    formatMinimum: { okStr: ">=", ok: n.GTE, fail: n.LT },
    formatExclusiveMaximum: { okStr: "<", ok: n.LT, fail: n.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: n.GT, fail: n.LTE }
  }, o = {
    message: ({ keyword: c, schemaCode: f }) => r.str`should be ${s[c].okStr} ${f}`,
    params: ({ keyword: c, schemaCode: f }) => r._`{comparison: ${s[c].okStr}, limit: ${f}}`
  };
  e.formatLimitDefinition = {
    keyword: Object.keys(s),
    type: "string",
    schemaType: "string",
    $data: !0,
    error: o,
    code(c) {
      const { gen: f, data: i, schemaCode: u, keyword: l, it: w } = c, { opts: b, self: h } = w;
      if (!b.validateFormats)
        return;
      const y = new t.KeywordCxt(w, h.RULES.all.format.definition, "format");
      y.$data ? _() : m();
      function _() {
        const O = f.scopeValue("formats", {
          ref: h.formats,
          code: b.code.formats
        }), j = f.const("fmt", r._`${O}[${y.schemaCode}]`);
        c.fail$data(r.or(r._`typeof ${j} != "object"`, r._`${j} instanceof RegExp`, r._`typeof ${j}.compare != "function"`, E(j)));
      }
      function m() {
        const O = y.schema, j = h.formats[O];
        if (!j || j === !0)
          return;
        if (typeof j != "object" || j instanceof RegExp || typeof j.compare != "function")
          throw new Error(`"${l}": format "${O}" does not define "compare" function`);
        const k = f.scopeValue("formats", {
          key: O,
          ref: j,
          code: b.code.formats ? r._`${b.code.formats}${r.getProperty(O)}` : void 0
        });
        c.fail$data(E(k));
      }
      function E(O) {
        return r._`${O}.compare(${i}, ${u}) ${s[l].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  const a = (c) => (c.addKeyword(e.formatLimitDefinition), c);
  e.default = a;
})(Xo);
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const r = xo, n = Xo, s = W, o = new s.Name("fullFormats"), a = new s.Name("fastFormats"), c = (i, u = { keywords: !0 }) => {
    if (Array.isArray(u))
      return f(i, u, r.fullFormats, o), i;
    const [l, w] = u.mode === "fast" ? [r.fastFormats, a] : [r.fullFormats, o], b = u.formats || r.formatNames;
    return f(i, b, l, w), u.keywords && n.default(i), i;
  };
  c.get = (i, u = "full") => {
    const w = (u === "fast" ? r.fastFormats : r.fullFormats)[i];
    if (!w)
      throw new Error(`Unknown format "${i}"`);
    return w;
  };
  function f(i, u, l, w) {
    var b, h;
    (b = (h = i.opts.code).formats) !== null && b !== void 0 || (h.formats = s._`require("ajv-formats/dist/formats").${w}`);
    for (const y of u)
      i.addFormat(y, l[y]);
  }
  e.exports = t = c, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = c;
})(Ul, Vr);
const xs = /* @__PURE__ */ ho(Vr);
function an(e, t) {
  const r = {};
  for (const [n] of Object.entries(t || {}))
    r[n] = e[n];
  return r;
}
function zl(e, t) {
  var w, b, h;
  let r = {}, n = {};
  const s = e.namespace || "", o = () => s ? t[s] || {} : t;
  function a(y) {
    return y.replace(/^\//, "").replace(/\//g, ".");
  }
  const c = (y, _) => {
    const m = new Ws({ allErrors: !0, allowUnionTypes: !0 });
    xs(m);
    const E = m.compile(y);
    if (!E(o())) {
      const j = E.errors;
      if (!j)
        throw new Error("Unknown error");
      const k = j[0], S = new Error(k.message);
      throw S.namespace = s, S.params = k.params, S.property = k.params.missingProperty ?? a(k.instancePath), S;
    }
  };
  if (e.server && Object.keys(e.server).length > 0) {
    try {
      c(e.server, "server");
    } catch (_) {
      throw _;
    }
    const y = an(o(), e.server.properties);
    s ? r[s] = y : r = y;
  }
  if (e.client && Object.keys(e.client).length > 0) {
    try {
      c(e.client, "client");
    } catch (_) {
      throw _;
    }
    const y = an(o(), e.client.properties);
    s ? n[s] = y : n = y;
  }
  if (e["*"] && Object.keys(e["*"]).length > 0) {
    const y = an(o(), e["*"].properties);
    try {
      c(e["*"], "both");
    } catch (_) {
      throw _;
    }
    s ? (r[s] = { ...r[s], ...y }, n[s] = { ...n[s], ...y }) : (r = { ...r, ...y }, n = { ...n, ...y });
  }
  function f(y) {
    if (y.type === "object" && ("additionalProperties" in y || (y.additionalProperties = !1), y.properties))
      for (const _ in y.properties)
        y.properties[_] = f(y.properties[_]);
    return y;
  }
  function i(y, _) {
    var j;
    const m = new Ws({ allErrors: !0, allowUnionTypes: !0 });
    xs(m);
    const E = m.compile(f(y));
    if (E(_))
      return [];
    {
      const k = [];
      return (j = E.errors) == null || j.forEach((S) => {
        var C;
        if (S.keyword === "additionalProperties") {
          const M = a(S.instancePath), F = M + (M ? "." : "") + ((C = S.params) == null ? void 0 : C.additionalProperty);
          k.push(F);
        }
      }), k;
    }
  }
  const u = {
    ...((w = e.server) == null ? void 0 : w.properties) || {},
    ...((b = e.client) == null ? void 0 : b.properties) || {},
    ...((h = e["*"]) == null ? void 0 : h.properties) || {}
  }, l = i({ type: "object", properties: u }, o()).filter((y) => y !== "modules").map((y) => s ? `${s}.${y}` : y);
  return { server: r, client: n, namespace: s, extraProps: l };
}
const Ve = {
  yellow: (e) => e,
  blue: (e) => e,
  red: (e) => e,
  dim: (e) => e
}, Vl = {
  compilerOptions: {
    type: "object",
    properties: {
      alias: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      },
      build: {
        type: "object",
        properties: {
          pwaEnabled: {
            type: "boolean"
          },
          assetsPath: {
            type: "string"
          },
          outputDir: {
            type: "string"
          },
          serverUrl: {
            type: "string"
          }
        }
      },
      spritesheetDirectories: {
        type: "array",
        items: {
          type: "string"
        }
      }
    }
  },
  vite: {
    type: "object",
    additionalProperties: !0
  }
}, Ll = {
  canvas: {
    type: "object",
    properties: {
      transparent: {
        type: "boolean"
      },
      autoDensity: {
        type: "boolean"
      },
      antialias: {
        type: "boolean"
      },
      resolution: {
        type: "number"
      },
      preserveDrawingBuffer: {
        type: "boolean"
      },
      backgroundColor: {
        type: "number"
      }
    }
  },
  selector: {
    type: "string"
  },
  selectorGui: {
    type: "string"
  },
  selectorCanvas: {
    type: "string"
  },
  standalone: {
    type: "boolean"
  },
  drawMap: {
    type: "boolean"
  },
  maxFps: {
    type: "number"
  },
  serverFps: {
    type: "number"
  }
}, ql = {
  express: {
    type: "object",
    properties: {
      static: {
        type: "string"
      },
      port: {
        type: "integer"
      },
      json: {
        type: "object",
        additionalProperties: !0
      },
      cors: {
        type: "object",
        additionalProperties: !0
      },
      socketIo: {
        type: "object",
        additionalProperties: !0
      }
    }
  }
}, Hl = {
  server: {
    type: "object",
    properties: {
      startMap: {
        type: "string"
      },
      start: {
        type: "object",
        properties: {
          map: {
            type: "string"
          },
          graphic: {
            type: "string"
          },
          hitbox: {
            type: "array",
            items: [
              { type: "integer" },
              { type: "integer" }
            ],
            additionalItems: !1,
            minItems: 2,
            maxItems: 2
          }
        }
      },
      api: {
        type: "object",
        properties: {
          enabled: {
            type: "boolean"
          },
          authSecret: {
            type: "string"
          }
        },
        required: ["enabled", "authSecret"]
      },
      ...Vl,
      ...ql
    }
  },
  client: {
    type: "object",
    properties: {
      shortName: {
        type: "string"
      },
      description: {
        type: "string"
      },
      themeColor: {
        type: "string"
      },
      icons: {
        type: "array",
        items: {
          type: "object",
          properties: {
            src: {
              type: "string"
            },
            sizes: {
              type: "array",
              items: {
                type: "number",
                minimum: 0
              }
            },
            type: {
              type: "string"
            }
          }
        }
      },
      themeCss: {
        type: "string"
      },
      matchMakerService: {
        type: "string"
      },
      pwa: {
        type: "object",
        additionalProperties: !0
      },
      ...Ll
    }
  },
  "*": {
    type: "object",
    properties: {
      inputs: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              type: "object",
              properties: {
                repeat: {
                  type: "boolean",
                  default: !1
                },
                bind: {
                  type: [
                    "string",
                    "array"
                  ]
                },
                delay: {
                  type: "object",
                  properties: {
                    duration: {
                      type: "number",
                      minimum: 0
                    },
                    otherControls: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    }
                  },
                  required: [
                    "duration"
                  ]
                }
              },
              required: [
                "bind"
              ]
            }
          ]
        }
      },
      name: {
        type: "string"
      }
    }
  }
};
function Lr(e) {
  console.log(Ve.yellow(`⚠️  Warning - ${e}`));
}
function Kl(e) {
  console.log(Ve.blue(`ℹ️  Info - ${e}`));
}
function Bl(e) {
  console.log(Ve.red(`❌  Error - ${e}`));
}
const Gl = (e) => {
  Bl(`${e.response.status} - ${e.response.data.error}`);
};
function Jl(e, t, r) {
  let n = {}, s = {}, o = [];
  const a = r.side == "server", c = (i, u) => {
    try {
      const l = zl(i, t);
      l.server && (s = { ...s, ...l.server }), l.client && (n = { ...n, ...l.client }), l.extraProps && (o = [...o, ...l.extraProps]);
    } catch (l) {
      if (!l.property)
        throw console.log(l), l;
      if (!a)
        return !1;
      let w = Ve.red(`Invalidate "${u}" module: ${l.message}`), b = `[${l.namespace}]
  ${l.property} = YOUR_VALUE`;
      throw u || (w = Ve.red(`Invalidate config: ${l.message}`), b = `${l.property} = YOUR_VALUE`), console.log("----------"), console.log(w), l.params.allowedValues && console.log(`
${Ve.dim("➜ Authorize values:")} ${Ve.dim(l.params.allowedValues.join(", "))}`), console.log(`${Ve.dim("➜")} ${Ve.dim(`you need to put the following configuration in rpg.toml:

${b}`)}`), console.log("----------"), l;
    }
  };
  c(Hl);
  let f = [];
  for (let i of e) {
    let u = i;
    u[0] != "." && (u = me.join("node_modules", u));
    const l = me.resolve(process.cwd(), u, "config.json");
    if (_e.existsSync(l)) {
      const w = _e.readFileSync(l, "utf-8"), b = JSON.parse(w);
      b.namespace && f.push(b.namespace), c(b, i);
    }
  }
  if (a) {
    const i = o.filter((u) => f.indexOf(u) == -1);
    if (i.length > 0) {
      Lr("In rpg.toml, you put the following properties, but they are not used by the modules. Check the names of the properties.");
      for (let u of i)
        console.log(`  - ${Ve.yellow(u)}`);
    }
  }
  return {
    configClient: n,
    configServer: s
  };
}
const cn = () => [], Wl = (e) => [
  ...cn(),
  ...cn(),
  ...cn()
], xl = (e) => me.join(e, "assets");
function sr(e) {
  return e.replace(/\\/g, "/");
}
function Yo(e) {
  const { cwd: t } = process;
  return sr(
    "./" + sr(me.relative(t(), e))
  );
}
function Qo(e, t) {
  const r = e.indexOf(t);
  if (r === -1)
    throw new Error("Project path not found in absolute path");
  return e.substring(r);
}
function Xs(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(e, s).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Ys(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Xs(Object(r), !0).forEach(function(n) {
      Xl(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Xs(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function Xl(e, t, r) {
  return t = Yl(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function Yl(e) {
  var t = Ql(e, "string");
  return typeof t == "symbol" ? t : String(t);
}
function Ql(e, t) {
  if (typeof e != "object" || e === null)
    return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (typeof n != "object")
      return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
const Je = Zo({});
function Zo(e) {
  return t.withOptions = (r) => Zo(Ys(Ys({}, e), r)), t;
  function t(r, ...n) {
    const s = typeof r == "string" ? [r] : r.raw, {
      escapeSpecialCharacters: o = Array.isArray(r)
    } = e;
    let a = "";
    for (let i = 0; i < s.length; i++) {
      let u = s[i];
      o && (u = u.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\{/g, "{")), a += u, i < n.length && (a += n[i]);
    }
    const c = a.split(`
`);
    let f = null;
    for (const i of c) {
      const u = i.match(/^(\s+)\S+/);
      if (u) {
        const l = u[1].length;
        f ? f = Math.min(f, l) : f = l;
      }
    }
    if (f !== null) {
      const i = f;
      a = c.map((u) => u[0] === " " || u[0] === "	" ? u.slice(i) : u).join(`
`);
    }
    return a.trim().replace(/\\n/g, `
`);
  }
}
var Qs = Object.freeze, Zl = Object.defineProperty, ed = (e, t) => Qs(Zl(e, "raw", { value: Qs(t || e.slice()) })), Zs;
const Wt = "virtual-modules", Nr = "virtual-config-client", Tr = "virtual-config-server", { cwd: or, exit: td } = process;
function qr(e) {
  return e = e.replace(/\./g, ""), e.replace(/[.@\/ -]/g, "_");
}
function ea(e) {
  return e.startsWith("@rpgjs") || e.startsWith("rpgjs") ? "node_modules/" + e : e;
}
function Wr(e) {
  const t = [], r = _e.readdirSync(e, { withFileTypes: !0 });
  for (const n of r) {
    const s = me.join(e, n.name);
    if (n.isDirectory()) {
      const o = Wr(s);
      t.push(...o);
    } else
      t.push(s);
  }
  return t;
}
function qe(e, t, r, n, s) {
  let o = "";
  const a = me.resolve(t, e);
  return _e.existsSync(a) ? {
    variablesString: Wr(a).filter((f) => typeof r == "string" ? f.endsWith(r) : r.some((i) => f.endsWith(i))).filter((f) => s != null && s.customFilter ? s.customFilter(f) : !0).map((f) => {
      const i = Yo(f), u = qr(i);
      return o = o + `
import ${u} from '${i}'`, n ? n(i, u) : u;
    }).join(","),
    importString: o,
    folder: a
  } : {
    variablesString: "",
    importString: "",
    folder: ""
  };
}
function Rt(e, t, r) {
  const n = me.resolve(or(), ea(e), t + ".ts");
  let s = "";
  return _e.existsSync(n) && (s = `import ${r || t} from '${e}/${t}.ts'`), s;
}
function ta(e, t, r) {
  var h, y, _;
  const { modulesCreated: n } = t;
  n.includes(e) || n.push(e);
  const s = Rt(e, "player"), o = Rt(e, "server"), a = qe("maps", e, ".ts"), c = qe("maps", e, ".tmx", (m, E) => `
            {
                id: '${m.replace(".tmx", "")}',
                file: ${E}
            }
        `, {
    customFilter: (m) => {
      const E = m.replace(".tmx", ".ts");
      return !_e.existsSync(E);
    }
  }), f = !!(c != null && c.variablesString), i = qe("worlds", e, ".world"), u = qe("database", e, ".ts"), l = qe("events", e, ".ts"), w = (h = r.start) == null ? void 0 : h.hitbox;
  return `
        import { type RpgServer, RpgModule } from '@rpgjs/server'
        ${c == null ? void 0 : c.importString}
        ${a == null ? void 0 : a.importString}
        ${i == null ? void 0 : i.importString}
        ${s || "const player = {}"}
        ${l == null ? void 0 : l.importString}
        ${u == null ? void 0 : u.importString}
        ${o}

        ${n.length == 1 ? Je`const _lastConnectedCb = player.onConnected
            player.onConnected = async (player) => {
                if (_lastConnectedCb) await _lastConnectedCb(player)
                if (!player.server.module.customHookExists('server.player.onAuth')) {
                    ${(y = r.start) != null && y.graphic ? `player.setGraphic('${(_ = r.start) == null ? void 0 : _.graphic}')` : ""}
                    ${w ? `player.setHitbox(${w[0]}, ${w[1]})` : ""}
                    ${r.startMap ? `await player.changeMap('${r.startMap}')` : ""}
                }
            }` : ""}
           
        @RpgModule<RpgServer>({ 
            player,
            events: [${l == null ? void 0 : l.variablesString}],
            ${o ? "engine: server," : ""}
            database: [${u == null ? void 0 : u.variablesString}],
            maps: [${c == null ? void 0 : c.variablesString}${f ? "," : ""}${a == null ? void 0 : a.variablesString}],
            worldMaps: [${i == null ? void 0 : i.variablesString}] 
        })
        export default class RpgServerModuleEngine {} 
    `;
}
function Rr(e, t, r, n = !1) {
  const s = qe(e, t, ".ts");
  let o = "";
  if (s != null && s.importString) {
    const a = s.folder;
    let c = "", f = "";
    const i = a.replace(or(), "/");
    if (Wr(a).filter((u) => [".png", ".jpg", ".jpeg", ".gif", ".bmp", ".webp", ".svg"].some((w) => u.toLowerCase().endsWith(w))).forEach(async (u) => {
      const l = me.basename(u), w = l.replace(me.extname(u), "");
      if (r.serveMode === !1) {
        const { outputDir: b = "dist" } = r.config.compilerOptions.build, h = me.join(b, xl(r.type === "rpg" ? "standalone" : "client"), l);
        _e.copyFileSync(u, h);
      }
      f = u, c += `"${w}": "${sr(Qo(u, i.replace(/^\/+/, "")))}",
`;
    }), !f)
      Lr(`No spritesheet image found in ${e} folder`);
    else {
      const u = Ba(f);
      o = `
            ${s == null ? void 0 : s.variablesString}.images = {
                ${c}
            }
            ${s == null ? void 0 : s.variablesString}.prototype.width = ${u.width}
            ${s == null ? void 0 : s.variablesString}.prototype.height = ${u.height}
        `;
    }
  } else
    n && Lr(`No spritesheet folder found in ${e} folder`);
  return {
    ...s,
    propImagesString: o
  };
}
function ra(e, t, r) {
  const n = Rt(e, "scene-map", "sceneMap"), s = Rt(e, "sprite"), o = Rt(e, "client", "engine"), a = qe("gui", e, ".vue");
  let c = [];
  const f = {
    config: r,
    ...t
  };
  r.spritesheetDirectories && (c = r.spritesheetDirectories.map((h) => Rr(h, e, f))), (r.spritesheetDirectories ?? []).some((h) => h === "characters") || c.push(Rr("characters", e, f, !1));
  const i = "spritesheets", u = me.join(e, i);
  if (_e.existsSync(u)) {
    const h = _e.readdirSync(u, { withFileTypes: !0 });
    for (const y of h)
      y.isDirectory() && c.push(Rr(me.join(i, y.name), e, f));
  }
  const l = qe("sounds", e, ".ts"), w = qe("sounds", e, [".mp3", ".ogg"], void 0, {
    customFilter: (h) => {
      const y = h.replace(/\.(mp3|ogg)$/, ".ts");
      return !_e.existsSync(y);
    }
  }), b = !!(w != null && w.variablesString);
  return c = c.filter((h) => h.importString), Je`
        import { type RpgClient, RpgModule } from '@rpgjs/client'
        ${s}
        ${n}
        ${o}
        ${c.map((h) => h.importString).join(`
`)}
        ${a == null ? void 0 : a.importString}
        ${w == null ? void 0 : w.importString}
        ${l == null ? void 0 : l.importString}

        ${c.map((h) => h.propImagesString).join(`
`)}
        
        @RpgModule<RpgClient>({ 
            spritesheets: [ ${c.map((h) => h.variablesString).join(`,
`)} ],
            sprite: ${s ? "sprite" : "{}"},
            ${o ? "engine," : ""}
            scenes: { ${n ? "map: sceneMap" : ""} },
            gui: [${a == null ? void 0 : a.variablesString}],
            sounds: [${w == null ? void 0 : w.variablesString}${b ? "," : ""}${l == null ? void 0 : l.variablesString}]
        })
        export default class RpgClientModuleEngine {}
    `;
}
function na(e, t, r, n, s) {
  const o = `virtual-${t}-client.ts`, a = `virtual-${t}-server.ts`;
  if (e.endsWith(a + "?server"))
    return ta(r, n, s);
  if (e.endsWith(o + "?client"))
    return ra(r, n, s);
  const c = me.join(or(), e), f = me.join(c, "package.json"), i = me.join(c, "index.ts");
  if (_e.existsSync(f)) {
    const { main: u } = JSON.parse(_e.readFileSync(f, "utf-8"));
    if (u) {
      const l = sr(me.join(e, u));
      return Je`
                import mod from '@/${l}'
                export default mod
            `;
    }
  } else if (_e.existsSync(i)) {
    const u = Qo(sr(i), e);
    return Je`
            import mod from '@/${u}'
            export default mod
        `;
  }
  return Je`
        import client from 'client!./${o}'
        import server from 'server!./${a}'
        
        export default {
            client,
            server
        } 
    `;
}
function sa(e, t, r) {
  return e.endsWith(Tr) ? `
            export default ${JSON.stringify(t)}
        ` : e.endsWith(Nr) ? `
            export default ${JSON.stringify(r)}
        ` : null;
}
function un(e) {
  return e.replace(/^.\//, "");
}
function rd(e = {}, t) {
  var f, i, u;
  let r = [], n = [];
  const s = (i = (f = t.vite) == null ? void 0 : f.build) == null ? void 0 : i.lib;
  if (t.modules && (r = t.modules), t.startMap = t.startMap || ((u = t.start) == null ? void 0 : u.map), t.inputs && e.server)
    for (let l in t.inputs) {
      const w = t.inputs[l];
      (typeof w.bind == "string" ? [w.bind] : w.bind).find((b) => ["1", "2", "3", "4"].includes(b)) && Lr(`Input "${l}" : Note that 1, 2, 3 or 4 designates a direction. Use up, right, bottom or left instead. If you want the number key, use n1, n2, n<number>.`);
    }
  let o;
  try {
    o = Jl(r, t, e);
  } catch {
    e.side == "server" && td();
  }
  if (!o)
    return;
  const { configClient: a, configServer: c } = o;
  return {
    name: "vite-plugin-config-toml",
    transformIndexHtml: {
      enforce: "pre",
      transform(l) {
        const w = me.resolve(or(), "src", "client.ts"), b = _e.existsSync(w) ? "mmorpg!./src/client.ts" : "mmorpg!virtual-client.ts", h = me.resolve(or(), "src", "standalone.ts"), y = _e.existsSync(h) ? "rpg!./src/standalone.ts" : "rpg!virtual-standalone.ts";
        return l.replace("<head>", Je(Zs || (Zs = ed([`
                <head>
                <script type="module">
                    import '`, `'
                    import '`, `'
                <\/script>`])), b, y));
      }
    },
    handleHotUpdate() {
      n = [];
    },
    async resolveId(l, w) {
      if (l.endsWith(Wt) || l.endsWith(Nr) || l.endsWith(Tr))
        return l;
      for (let b of r)
        if (l === un(b))
          return l;
      if (l.includes("virtual") && !l.endsWith("virtual-server.ts") && e.serveMode || l.includes("virtual") && !e.serveMode)
        return l;
    },
    async load(l) {
      const { env: w } = process, b = w.VITE_SERVER_URL, h = `{
                VITE_BUILT: ${w.VITE_BUILT},
                VITE_SERVER_URL: ${b ? "'" + b + "'" : "undefined"},
                VITE_RPG_TYPE: '${e.type ?? "mmorpg"}',
                VITE_ASSETS_PATH: '${w.VITE_ASSETS_PATH ?? ""}'
            }`;
      if (l.endsWith(Wt)) {
        const _ = r.reduce((m, E) => {
          const O = qr(E);
          return m[O] = E, m;
        }, {});
        return `
                ${Object.keys(_).map((m) => `import ${m} from '${un(_[m])}'`).join(`
`)}

                export default [
                   ${Object.keys(_).join(`,
`)}
                ]
                `;
      } else {
        if (l.endsWith("virtual-client.ts?mmorpg"))
          return Je`
                import { entryPoint } from '@rpgjs/client'
                import io from 'socket.io-client'
                import modules from './${Wt}'
                import globalConfig from './${Nr}'

                document.addEventListener('DOMContentLoaded', function(e) { 
                    entryPoint(modules, { 
                        io,
                        globalConfig,
                        envs: ${h}
                    }).start()
                });
              `;
        if (l.endsWith("virtual-standalone.ts?rpg"))
          return Je`
                import { entryPoint } from '@rpgjs/standalone'
                import globalConfigClient from './${Nr}'
                import globalConfigServer from './${Tr}'
                import modules from './${Wt}'

                ${s ? `  window.global ||= window
                 
                    export default (extraModules = []) => {
                        return entryPoint([
                            ...modules,
                            ...extraModules
                        ], {
                            globalConfigClient,
                            globalConfigServer,
                            envs: ${h}
                        })
                    }
                 ` : `document.addEventListener('DOMContentLoaded', async function() { 
                        window.RpgStandalone = await entryPoint(modules, {
                            globalConfigClient,
                            globalConfigServer,
                            envs: ${h}
                        }).start() 
                    })`}

              `;
        if (l.endsWith("virtual-server.ts"))
          return Je`
                import { expressServer } from '@rpgjs/server/express'
                import * as url from 'url'
                import modules from './${Wt}'
                import globalConfig from './${Tr}'

                const __dirname = url.fileURLToPath(new URL('.', import.meta.url))

                expressServer(modules, {
                    globalConfig,
                    basePath: __dirname,
                    envs: ${h}
                })
              `;
      }
      const y = sa(l, c, a);
      if (y)
        return y;
      for (let _ of r) {
        let m = un(_), E = qr(m);
        if (l.endsWith(m) || l.includes("virtual-" + E))
          return na(l, E, _, {
            ...e,
            modulesCreated: n
          }, t);
      }
    }
  };
}
const vf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createConfigFiles: sa,
  createModuleLoad: na,
  default: rd,
  formatVariableName: qr,
  getAllFiles: Wr,
  importString: Rt,
  loadClientFiles: ra,
  loadServerFiles: ta,
  loadSpriteSheet: Rr,
  searchFolderAndTransformToImportString: qe,
  transformPathIfModule: ea
}, Symbol.toStringTag, { value: "Module" }));
function $f(e = {}) {
  const { side: t = "client", mode: r = "development", type: n = "mmorpg" } = e;
  async function s(a, c, f) {
    const i = ["client!", "server!", "rpg!", "mmorpg!", "production!", "development!"];
    for (const u of i)
      if (a.startsWith(u)) {
        const l = a.replace(u, ""), w = await this.resolve(l, c, {
          skipSelf: !0,
          ...f
        });
        return {
          ...w,
          id: w.id + `?${u.replace("!", "")}`
        };
      }
  }
  async function o(a, c) {
    let f = a;
    return r === "test" ? {
      code: f,
      map: null
    } : ((c.endsWith(t === "client" ? "?server" : "?client") && n !== "rpg" || c.endsWith("?production") && r !== "production" || c.endsWith("?development") && r !== "development" || c.endsWith("?rpg") && n !== "rpg" || c.endsWith("?mmorpg") && n !== "mmorpg") && (f = "export default null;"), {
      code: f,
      map: null
    });
  }
  return {
    name: "transform-flag",
    resolveId: s,
    transform: o
  };
}
function oa(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: nd } = Object.prototype, { getPrototypeOf: ds } = Object, xr = ((e) => (t) => {
  const r = nd.call(t);
  return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Qe = (e) => (e = e.toLowerCase(), (t) => xr(t) === e), Xr = (e) => (t) => typeof t === e, { isArray: kt } = Array, ar = Xr("undefined");
function sd(e) {
  return e !== null && !ar(e) && e.constructor !== null && !ar(e.constructor) && Ye(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const aa = Qe("ArrayBuffer");
function od(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && aa(e.buffer), t;
}
const ad = Xr("string"), Ye = Xr("function"), ia = Xr("number"), fs = (e) => e !== null && typeof e == "object", id = (e) => e === !0 || e === !1, Cr = (e) => {
  if (xr(e) !== "object")
    return !1;
  const t = ds(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, cd = Qe("Date"), ud = Qe("File"), ld = Qe("Blob"), dd = Qe("FileList"), fd = (e) => fs(e) && Ye(e.pipe), pd = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || Ye(e.append) && ((t = xr(e)) === "formdata" || // detect form-data instance
  t === "object" && Ye(e.toString) && e.toString() === "[object FormData]"));
}, hd = Qe("URLSearchParams"), md = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function fr(e, t, { allOwnKeys: r = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let n, s;
  if (typeof e != "object" && (e = [e]), kt(e))
    for (n = 0, s = e.length; n < s; n++)
      t.call(null, e[n], n, e);
  else {
    const o = r ? Object.getOwnPropertyNames(e) : Object.keys(e), a = o.length;
    let c;
    for (n = 0; n < a; n++)
      c = o[n], t.call(null, e[c], c, e);
  }
}
function ca(e, t) {
  t = t.toLowerCase();
  const r = Object.keys(e);
  let n = r.length, s;
  for (; n-- > 0; )
    if (s = r[n], t === s.toLowerCase())
      return s;
  return null;
}
const ua = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), la = (e) => !ar(e) && e !== ua;
function wn() {
  const { caseless: e } = la(this) && this || {}, t = {}, r = (n, s) => {
    const o = e && ca(t, s) || s;
    Cr(t[o]) && Cr(n) ? t[o] = wn(t[o], n) : Cr(n) ? t[o] = wn({}, n) : kt(n) ? t[o] = n.slice() : t[o] = n;
  };
  for (let n = 0, s = arguments.length; n < s; n++)
    arguments[n] && fr(arguments[n], r);
  return t;
}
const yd = (e, t, r, { allOwnKeys: n } = {}) => (fr(t, (s, o) => {
  r && Ye(s) ? e[o] = oa(s, r) : e[o] = s;
}, { allOwnKeys: n }), e), gd = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), vd = (e, t, r, n) => {
  e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), r && Object.assign(e.prototype, r);
}, $d = (e, t, r, n) => {
  let s, o, a;
  const c = {};
  if (t = t || {}, e == null)
    return t;
  do {
    for (s = Object.getOwnPropertyNames(e), o = s.length; o-- > 0; )
      a = s[o], (!n || n(a, e, t)) && !c[a] && (t[a] = e[a], c[a] = !0);
    e = r !== !1 && ds(e);
  } while (e && (!r || r(e, t)) && e !== Object.prototype);
  return t;
}, _d = (e, t, r) => {
  e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= t.length;
  const n = e.indexOf(t, r);
  return n !== -1 && n === r;
}, wd = (e) => {
  if (!e)
    return null;
  if (kt(e))
    return e;
  let t = e.length;
  if (!ia(t))
    return null;
  const r = new Array(t);
  for (; t-- > 0; )
    r[t] = e[t];
  return r;
}, bd = ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && ds(Uint8Array)), Ed = (e, t) => {
  const n = (e && e[Symbol.iterator]).call(e);
  let s;
  for (; (s = n.next()) && !s.done; ) {
    const o = s.value;
    t.call(e, o[0], o[1]);
  }
}, Sd = (e, t) => {
  let r;
  const n = [];
  for (; (r = e.exec(t)) !== null; )
    n.push(r);
  return n;
}, Pd = Qe("HTMLFormElement"), Od = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, n, s) {
    return n.toUpperCase() + s;
  }
), eo = (({ hasOwnProperty: e }) => (t, r) => e.call(t, r))(Object.prototype), Nd = Qe("RegExp"), da = (e, t) => {
  const r = Object.getOwnPropertyDescriptors(e), n = {};
  fr(r, (s, o) => {
    t(s, o, e) !== !1 && (n[o] = s);
  }), Object.defineProperties(e, n);
}, Td = (e) => {
  da(e, (t, r) => {
    if (Ye(e) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const n = e[r];
    if (Ye(n)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
}, Rd = (e, t) => {
  const r = {}, n = (s) => {
    s.forEach((o) => {
      r[o] = !0;
    });
  };
  return kt(e) ? n(e) : n(String(e).split(t)), r;
}, Cd = () => {
}, jd = (e, t) => (e = +e, Number.isFinite(e) ? e : t), ln = "abcdefghijklmnopqrstuvwxyz", to = "0123456789", fa = {
  DIGIT: to,
  ALPHA: ln,
  ALPHA_DIGIT: ln + ln.toUpperCase() + to
}, Ad = (e = 16, t = fa.ALPHA_DIGIT) => {
  let r = "";
  const { length: n } = t;
  for (; e--; )
    r += t[Math.random() * n | 0];
  return r;
};
function Id(e) {
  return !!(e && Ye(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const Dd = (e) => {
  const t = new Array(10), r = (n, s) => {
    if (fs(n)) {
      if (t.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        t[s] = n;
        const o = kt(n) ? [] : {};
        return fr(n, (a, c) => {
          const f = r(a, s + 1);
          !ar(f) && (o[c] = f);
        }), t[s] = void 0, o;
      }
    }
    return n;
  };
  return r(e, 0);
}, I = {
  isArray: kt,
  isArrayBuffer: aa,
  isBuffer: sd,
  isFormData: pd,
  isArrayBufferView: od,
  isString: ad,
  isNumber: ia,
  isBoolean: id,
  isObject: fs,
  isPlainObject: Cr,
  isUndefined: ar,
  isDate: cd,
  isFile: ud,
  isBlob: ld,
  isRegExp: Nd,
  isFunction: Ye,
  isStream: fd,
  isURLSearchParams: hd,
  isTypedArray: bd,
  isFileList: dd,
  forEach: fr,
  merge: wn,
  extend: yd,
  trim: md,
  stripBOM: gd,
  inherits: vd,
  toFlatObject: $d,
  kindOf: xr,
  kindOfTest: Qe,
  endsWith: _d,
  toArray: wd,
  forEachEntry: Ed,
  matchAll: Sd,
  isHTMLForm: Pd,
  hasOwnProperty: eo,
  hasOwnProp: eo,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: da,
  freezeMethods: Td,
  toObjectSet: Rd,
  toCamelCase: Od,
  noop: Cd,
  toFiniteNumber: jd,
  findKey: ca,
  global: ua,
  isContextDefined: la,
  ALPHABET: fa,
  generateString: Ad,
  isSpecCompliantForm: Id,
  toJSONObject: Dd
};
function te(e, t, r, n, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), s && (this.response = s);
}
I.inherits(te, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: I.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const pa = te.prototype, ha = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  ha[e] = { value: e };
});
Object.defineProperties(te, ha);
Object.defineProperty(pa, "isAxiosError", { value: !0 });
te.from = (e, t, r, n, s, o) => {
  const a = Object.create(pa);
  return I.toFlatObject(e, a, function(f) {
    return f !== Error.prototype;
  }, (c) => c !== "isAxiosError"), te.call(a, e.message, t, r, n, s), a.cause = e, a.name = e.name, o && Object.assign(a, o), a;
};
const kd = null;
function bn(e) {
  return I.isPlainObject(e) || I.isArray(e);
}
function ma(e) {
  return I.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function ro(e, t, r) {
  return e ? e.concat(t).map(function(s, o) {
    return s = ma(s), !r && o ? "[" + s + "]" : s;
  }).join(r ? "." : "") : t;
}
function Md(e) {
  return I.isArray(e) && !e.some(bn);
}
const Fd = I.toFlatObject(I, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function Yr(e, t, r) {
  if (!I.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), r = I.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(y, _) {
    return !I.isUndefined(_[y]);
  });
  const n = r.metaTokens, s = r.visitor || u, o = r.dots, a = r.indexes, f = (r.Blob || typeof Blob < "u" && Blob) && I.isSpecCompliantForm(t);
  if (!I.isFunction(s))
    throw new TypeError("visitor must be a function");
  function i(h) {
    if (h === null)
      return "";
    if (I.isDate(h))
      return h.toISOString();
    if (!f && I.isBlob(h))
      throw new te("Blob is not supported. Use a Buffer instead.");
    return I.isArrayBuffer(h) || I.isTypedArray(h) ? f && typeof Blob == "function" ? new Blob([h]) : Buffer.from(h) : h;
  }
  function u(h, y, _) {
    let m = h;
    if (h && !_ && typeof h == "object") {
      if (I.endsWith(y, "{}"))
        y = n ? y : y.slice(0, -2), h = JSON.stringify(h);
      else if (I.isArray(h) && Md(h) || (I.isFileList(h) || I.endsWith(y, "[]")) && (m = I.toArray(h)))
        return y = ma(y), m.forEach(function(O, j) {
          !(I.isUndefined(O) || O === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            a === !0 ? ro([y], j, o) : a === null ? y : y + "[]",
            i(O)
          );
        }), !1;
    }
    return bn(h) ? !0 : (t.append(ro(_, y, o), i(h)), !1);
  }
  const l = [], w = Object.assign(Fd, {
    defaultVisitor: u,
    convertValue: i,
    isVisitable: bn
  });
  function b(h, y) {
    if (!I.isUndefined(h)) {
      if (l.indexOf(h) !== -1)
        throw Error("Circular reference detected in " + y.join("."));
      l.push(h), I.forEach(h, function(m, E) {
        (!(I.isUndefined(m) || m === null) && s.call(
          t,
          m,
          I.isString(E) ? E.trim() : E,
          y,
          w
        )) === !0 && b(m, y ? y.concat(E) : [E]);
      }), l.pop();
    }
  }
  if (!I.isObject(e))
    throw new TypeError("data must be an object");
  return b(e), t;
}
function no(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(n) {
    return t[n];
  });
}
function ps(e, t) {
  this._pairs = [], e && Yr(e, this, t);
}
const ya = ps.prototype;
ya.append = function(t, r) {
  this._pairs.push([t, r]);
};
ya.toString = function(t) {
  const r = t ? function(n) {
    return t.call(this, n, no);
  } : no;
  return this._pairs.map(function(s) {
    return r(s[0]) + "=" + r(s[1]);
  }, "").join("&");
};
function Ud(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function ga(e, t, r) {
  if (!t)
    return e;
  const n = r && r.encode || Ud, s = r && r.serialize;
  let o;
  if (s ? o = s(t, r) : o = I.isURLSearchParams(t) ? t.toString() : new ps(t, r).toString(n), o) {
    const a = e.indexOf("#");
    a !== -1 && (e = e.slice(0, a)), e += (e.indexOf("?") === -1 ? "?" : "&") + o;
  }
  return e;
}
class zd {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, r, n) {
    return this.handlers.push({
      fulfilled: t,
      rejected: r,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    I.forEach(this.handlers, function(n) {
      n !== null && t(n);
    });
  }
}
const so = zd, va = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, Vd = typeof URLSearchParams < "u" ? URLSearchParams : ps, Ld = typeof FormData < "u" ? FormData : null, qd = typeof Blob < "u" ? Blob : null, Hd = (() => {
  let e;
  return typeof navigator < "u" && ((e = navigator.product) === "ReactNative" || e === "NativeScript" || e === "NS") ? !1 : typeof window < "u" && typeof document < "u";
})(), Kd = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), Ke = {
  isBrowser: !0,
  classes: {
    URLSearchParams: Vd,
    FormData: Ld,
    Blob: qd
  },
  isStandardBrowserEnv: Hd,
  isStandardBrowserWebWorkerEnv: Kd,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function Bd(e, t) {
  return Yr(e, new Ke.classes.URLSearchParams(), Object.assign({
    visitor: function(r, n, s, o) {
      return Ke.isNode && I.isBuffer(r) ? (this.append(n, r.toString("base64")), !1) : o.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function Gd(e) {
  return I.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function Jd(e) {
  const t = {}, r = Object.keys(e);
  let n;
  const s = r.length;
  let o;
  for (n = 0; n < s; n++)
    o = r[n], t[o] = e[o];
  return t;
}
function $a(e) {
  function t(r, n, s, o) {
    let a = r[o++];
    const c = Number.isFinite(+a), f = o >= r.length;
    return a = !a && I.isArray(s) ? s.length : a, f ? (I.hasOwnProp(s, a) ? s[a] = [s[a], n] : s[a] = n, !c) : ((!s[a] || !I.isObject(s[a])) && (s[a] = []), t(r, n, s[a], o) && I.isArray(s[a]) && (s[a] = Jd(s[a])), !c);
  }
  if (I.isFormData(e) && I.isFunction(e.entries)) {
    const r = {};
    return I.forEachEntry(e, (n, s) => {
      t(Gd(n), s, r, 0);
    }), r;
  }
  return null;
}
const Wd = {
  "Content-Type": void 0
};
function xd(e, t, r) {
  if (I.isString(e))
    try {
      return (t || JSON.parse)(e), I.trim(e);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (r || JSON.stringify)(e);
}
const Qr = {
  transitional: va,
  adapter: ["xhr", "http"],
  transformRequest: [function(t, r) {
    const n = r.getContentType() || "", s = n.indexOf("application/json") > -1, o = I.isObject(t);
    if (o && I.isHTMLForm(t) && (t = new FormData(t)), I.isFormData(t))
      return s && s ? JSON.stringify($a(t)) : t;
    if (I.isArrayBuffer(t) || I.isBuffer(t) || I.isStream(t) || I.isFile(t) || I.isBlob(t))
      return t;
    if (I.isArrayBufferView(t))
      return t.buffer;
    if (I.isURLSearchParams(t))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let c;
    if (o) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return Bd(t, this.formSerializer).toString();
      if ((c = I.isFileList(t)) || n.indexOf("multipart/form-data") > -1) {
        const f = this.env && this.env.FormData;
        return Yr(
          c ? { "files[]": t } : t,
          f && new f(),
          this.formSerializer
        );
      }
    }
    return o || s ? (r.setContentType("application/json", !1), xd(t)) : t;
  }],
  transformResponse: [function(t) {
    const r = this.transitional || Qr.transitional, n = r && r.forcedJSONParsing, s = this.responseType === "json";
    if (t && I.isString(t) && (n && !this.responseType || s)) {
      const a = !(r && r.silentJSONParsing) && s;
      try {
        return JSON.parse(t);
      } catch (c) {
        if (a)
          throw c.name === "SyntaxError" ? te.from(c, te.ERR_BAD_RESPONSE, this, null, this.response) : c;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Ke.classes.FormData,
    Blob: Ke.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  }
};
I.forEach(["delete", "get", "head"], function(t) {
  Qr.headers[t] = {};
});
I.forEach(["post", "put", "patch"], function(t) {
  Qr.headers[t] = I.merge(Wd);
});
const hs = Qr, Xd = I.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), Yd = (e) => {
  const t = {};
  let r, n, s;
  return e && e.split(`
`).forEach(function(a) {
    s = a.indexOf(":"), r = a.substring(0, s).trim().toLowerCase(), n = a.substring(s + 1).trim(), !(!r || t[r] && Xd[r]) && (r === "set-cookie" ? t[r] ? t[r].push(n) : t[r] = [n] : t[r] = t[r] ? t[r] + ", " + n : n);
  }), t;
}, oo = Symbol("internals");
function xt(e) {
  return e && String(e).trim().toLowerCase();
}
function jr(e) {
  return e === !1 || e == null ? e : I.isArray(e) ? e.map(jr) : String(e);
}
function Qd(e) {
  const t = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = r.exec(e); )
    t[n[1]] = n[2];
  return t;
}
const Zd = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function dn(e, t, r, n, s) {
  if (I.isFunction(n))
    return n.call(this, t, r);
  if (s && (t = r), !!I.isString(t)) {
    if (I.isString(n))
      return t.indexOf(n) !== -1;
    if (I.isRegExp(n))
      return n.test(t);
  }
}
function ef(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, r, n) => r.toUpperCase() + n);
}
function tf(e, t) {
  const r = I.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(e, n + r, {
      value: function(s, o, a) {
        return this[n].call(this, t, s, o, a);
      },
      configurable: !0
    });
  });
}
class Zr {
  constructor(t) {
    t && this.set(t);
  }
  set(t, r, n) {
    const s = this;
    function o(c, f, i) {
      const u = xt(f);
      if (!u)
        throw new Error("header name must be a non-empty string");
      const l = I.findKey(s, u);
      (!l || s[l] === void 0 || i === !0 || i === void 0 && s[l] !== !1) && (s[l || f] = jr(c));
    }
    const a = (c, f) => I.forEach(c, (i, u) => o(i, u, f));
    return I.isPlainObject(t) || t instanceof this.constructor ? a(t, r) : I.isString(t) && (t = t.trim()) && !Zd(t) ? a(Yd(t), r) : t != null && o(r, t, n), this;
  }
  get(t, r) {
    if (t = xt(t), t) {
      const n = I.findKey(this, t);
      if (n) {
        const s = this[n];
        if (!r)
          return s;
        if (r === !0)
          return Qd(s);
        if (I.isFunction(r))
          return r.call(this, s, n);
        if (I.isRegExp(r))
          return r.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, r) {
    if (t = xt(t), t) {
      const n = I.findKey(this, t);
      return !!(n && this[n] !== void 0 && (!r || dn(this, this[n], n, r)));
    }
    return !1;
  }
  delete(t, r) {
    const n = this;
    let s = !1;
    function o(a) {
      if (a = xt(a), a) {
        const c = I.findKey(n, a);
        c && (!r || dn(n, n[c], c, r)) && (delete n[c], s = !0);
      }
    }
    return I.isArray(t) ? t.forEach(o) : o(t), s;
  }
  clear(t) {
    const r = Object.keys(this);
    let n = r.length, s = !1;
    for (; n--; ) {
      const o = r[n];
      (!t || dn(this, this[o], o, t, !0)) && (delete this[o], s = !0);
    }
    return s;
  }
  normalize(t) {
    const r = this, n = {};
    return I.forEach(this, (s, o) => {
      const a = I.findKey(n, o);
      if (a) {
        r[a] = jr(s), delete r[o];
        return;
      }
      const c = t ? ef(o) : String(o).trim();
      c !== o && delete r[o], r[c] = jr(s), n[c] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const r = /* @__PURE__ */ Object.create(null);
    return I.forEach(this, (n, s) => {
      n != null && n !== !1 && (r[s] = t && I.isArray(n) ? n.join(", ") : n);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, r]) => t + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...r) {
    const n = new this(t);
    return r.forEach((s) => n.set(s)), n;
  }
  static accessor(t) {
    const n = (this[oo] = this[oo] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function o(a) {
      const c = xt(a);
      n[c] || (tf(s, a), n[c] = !0);
    }
    return I.isArray(t) ? t.forEach(o) : o(t), this;
  }
}
Zr.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
I.freezeMethods(Zr.prototype);
I.freezeMethods(Zr);
const Xe = Zr;
function fn(e, t) {
  const r = this || hs, n = t || r, s = Xe.from(n.headers);
  let o = n.data;
  return I.forEach(e, function(c) {
    o = c.call(r, o, s.normalize(), t ? t.status : void 0);
  }), s.normalize(), o;
}
function _a(e) {
  return !!(e && e.__CANCEL__);
}
function pr(e, t, r) {
  te.call(this, e ?? "canceled", te.ERR_CANCELED, t, r), this.name = "CanceledError";
}
I.inherits(pr, te, {
  __CANCEL__: !0
});
function rf(e, t, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? e(r) : t(new te(
    "Request failed with status code " + r.status,
    [te.ERR_BAD_REQUEST, te.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
const nf = Ke.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function() {
    return {
      write: function(r, n, s, o, a, c) {
        const f = [];
        f.push(r + "=" + encodeURIComponent(n)), I.isNumber(s) && f.push("expires=" + new Date(s).toGMTString()), I.isString(o) && f.push("path=" + o), I.isString(a) && f.push("domain=" + a), c === !0 && f.push("secure"), document.cookie = f.join("; ");
      },
      read: function(r) {
        const n = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
        return n ? decodeURIComponent(n[3]) : null;
      },
      remove: function(r) {
        this.write(r, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function() {
    return {
      write: function() {
      },
      read: function() {
        return null;
      },
      remove: function() {
      }
    };
  }()
);
function sf(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function of(e, t) {
  return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function wa(e, t) {
  return e && !sf(t) ? of(e, t) : t;
}
const af = Ke.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement("a");
    let n;
    function s(o) {
      let a = o;
      return t && (r.setAttribute("href", a), a = r.href), r.setAttribute("href", a), {
        href: r.href,
        protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
        host: r.host,
        search: r.search ? r.search.replace(/^\?/, "") : "",
        hash: r.hash ? r.hash.replace(/^#/, "") : "",
        hostname: r.hostname,
        port: r.port,
        pathname: r.pathname.charAt(0) === "/" ? r.pathname : "/" + r.pathname
      };
    }
    return n = s(window.location.href), function(a) {
      const c = I.isString(a) ? s(a) : a;
      return c.protocol === n.protocol && c.host === n.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function() {
    return function() {
      return !0;
    };
  }()
);
function cf(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function uf(e, t) {
  e = e || 10;
  const r = new Array(e), n = new Array(e);
  let s = 0, o = 0, a;
  return t = t !== void 0 ? t : 1e3, function(f) {
    const i = Date.now(), u = n[o];
    a || (a = i), r[s] = f, n[s] = i;
    let l = o, w = 0;
    for (; l !== s; )
      w += r[l++], l = l % e;
    if (s = (s + 1) % e, s === o && (o = (o + 1) % e), i - a < t)
      return;
    const b = u && i - u;
    return b ? Math.round(w * 1e3 / b) : void 0;
  };
}
function ao(e, t) {
  let r = 0;
  const n = uf(50, 250);
  return (s) => {
    const o = s.loaded, a = s.lengthComputable ? s.total : void 0, c = o - r, f = n(c), i = o <= a;
    r = o;
    const u = {
      loaded: o,
      total: a,
      progress: a ? o / a : void 0,
      bytes: c,
      rate: f || void 0,
      estimated: f && a && i ? (a - o) / f : void 0,
      event: s
    };
    u[t ? "download" : "upload"] = !0, e(u);
  };
}
const lf = typeof XMLHttpRequest < "u", df = lf && function(e) {
  return new Promise(function(r, n) {
    let s = e.data;
    const o = Xe.from(e.headers).normalize(), a = e.responseType;
    let c;
    function f() {
      e.cancelToken && e.cancelToken.unsubscribe(c), e.signal && e.signal.removeEventListener("abort", c);
    }
    I.isFormData(s) && (Ke.isStandardBrowserEnv || Ke.isStandardBrowserWebWorkerEnv) && o.setContentType(!1);
    let i = new XMLHttpRequest();
    if (e.auth) {
      const b = e.auth.username || "", h = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
      o.set("Authorization", "Basic " + btoa(b + ":" + h));
    }
    const u = wa(e.baseURL, e.url);
    i.open(e.method.toUpperCase(), ga(u, e.params, e.paramsSerializer), !0), i.timeout = e.timeout;
    function l() {
      if (!i)
        return;
      const b = Xe.from(
        "getAllResponseHeaders" in i && i.getAllResponseHeaders()
      ), y = {
        data: !a || a === "text" || a === "json" ? i.responseText : i.response,
        status: i.status,
        statusText: i.statusText,
        headers: b,
        config: e,
        request: i
      };
      rf(function(m) {
        r(m), f();
      }, function(m) {
        n(m), f();
      }, y), i = null;
    }
    if ("onloadend" in i ? i.onloadend = l : i.onreadystatechange = function() {
      !i || i.readyState !== 4 || i.status === 0 && !(i.responseURL && i.responseURL.indexOf("file:") === 0) || setTimeout(l);
    }, i.onabort = function() {
      i && (n(new te("Request aborted", te.ECONNABORTED, e, i)), i = null);
    }, i.onerror = function() {
      n(new te("Network Error", te.ERR_NETWORK, e, i)), i = null;
    }, i.ontimeout = function() {
      let h = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
      const y = e.transitional || va;
      e.timeoutErrorMessage && (h = e.timeoutErrorMessage), n(new te(
        h,
        y.clarifyTimeoutError ? te.ETIMEDOUT : te.ECONNABORTED,
        e,
        i
      )), i = null;
    }, Ke.isStandardBrowserEnv) {
      const b = (e.withCredentials || af(u)) && e.xsrfCookieName && nf.read(e.xsrfCookieName);
      b && o.set(e.xsrfHeaderName, b);
    }
    s === void 0 && o.setContentType(null), "setRequestHeader" in i && I.forEach(o.toJSON(), function(h, y) {
      i.setRequestHeader(y, h);
    }), I.isUndefined(e.withCredentials) || (i.withCredentials = !!e.withCredentials), a && a !== "json" && (i.responseType = e.responseType), typeof e.onDownloadProgress == "function" && i.addEventListener("progress", ao(e.onDownloadProgress, !0)), typeof e.onUploadProgress == "function" && i.upload && i.upload.addEventListener("progress", ao(e.onUploadProgress)), (e.cancelToken || e.signal) && (c = (b) => {
      i && (n(!b || b.type ? new pr(null, e, i) : b), i.abort(), i = null);
    }, e.cancelToken && e.cancelToken.subscribe(c), e.signal && (e.signal.aborted ? c() : e.signal.addEventListener("abort", c)));
    const w = cf(u);
    if (w && Ke.protocols.indexOf(w) === -1) {
      n(new te("Unsupported protocol " + w + ":", te.ERR_BAD_REQUEST, e));
      return;
    }
    i.send(s || null);
  });
}, Ar = {
  http: kd,
  xhr: df
};
I.forEach(Ar, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const ff = {
  getAdapter: (e) => {
    e = I.isArray(e) ? e : [e];
    const { length: t } = e;
    let r, n;
    for (let s = 0; s < t && (r = e[s], !(n = I.isString(r) ? Ar[r.toLowerCase()] : r)); s++)
      ;
    if (!n)
      throw n === !1 ? new te(
        `Adapter ${r} is not supported by the environment`,
        "ERR_NOT_SUPPORT"
      ) : new Error(
        I.hasOwnProp(Ar, r) ? `Adapter '${r}' is not available in the build` : `Unknown adapter '${r}'`
      );
    if (!I.isFunction(n))
      throw new TypeError("adapter is not a function");
    return n;
  },
  adapters: Ar
};
function pn(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new pr(null, e);
}
function io(e) {
  return pn(e), e.headers = Xe.from(e.headers), e.data = fn.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), ff.getAdapter(e.adapter || hs.adapter)(e).then(function(n) {
    return pn(e), n.data = fn.call(
      e,
      e.transformResponse,
      n
    ), n.headers = Xe.from(n.headers), n;
  }, function(n) {
    return _a(n) || (pn(e), n && n.response && (n.response.data = fn.call(
      e,
      e.transformResponse,
      n.response
    ), n.response.headers = Xe.from(n.response.headers))), Promise.reject(n);
  });
}
const co = (e) => e instanceof Xe ? e.toJSON() : e;
function At(e, t) {
  t = t || {};
  const r = {};
  function n(i, u, l) {
    return I.isPlainObject(i) && I.isPlainObject(u) ? I.merge.call({ caseless: l }, i, u) : I.isPlainObject(u) ? I.merge({}, u) : I.isArray(u) ? u.slice() : u;
  }
  function s(i, u, l) {
    if (I.isUndefined(u)) {
      if (!I.isUndefined(i))
        return n(void 0, i, l);
    } else
      return n(i, u, l);
  }
  function o(i, u) {
    if (!I.isUndefined(u))
      return n(void 0, u);
  }
  function a(i, u) {
    if (I.isUndefined(u)) {
      if (!I.isUndefined(i))
        return n(void 0, i);
    } else
      return n(void 0, u);
  }
  function c(i, u, l) {
    if (l in t)
      return n(i, u);
    if (l in e)
      return n(void 0, i);
  }
  const f = {
    url: o,
    method: o,
    data: o,
    baseURL: a,
    transformRequest: a,
    transformResponse: a,
    paramsSerializer: a,
    timeout: a,
    timeoutMessage: a,
    withCredentials: a,
    adapter: a,
    responseType: a,
    xsrfCookieName: a,
    xsrfHeaderName: a,
    onUploadProgress: a,
    onDownloadProgress: a,
    decompress: a,
    maxContentLength: a,
    maxBodyLength: a,
    beforeRedirect: a,
    transport: a,
    httpAgent: a,
    httpsAgent: a,
    cancelToken: a,
    socketPath: a,
    responseEncoding: a,
    validateStatus: c,
    headers: (i, u) => s(co(i), co(u), !0)
  };
  return I.forEach(Object.keys(e).concat(Object.keys(t)), function(u) {
    const l = f[u] || s, w = l(e[u], t[u], u);
    I.isUndefined(w) && l !== c || (r[u] = w);
  }), r;
}
const ba = "1.3.6", ms = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  ms[e] = function(n) {
    return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const uo = {};
ms.transitional = function(t, r, n) {
  function s(o, a) {
    return "[Axios v" + ba + "] Transitional option '" + o + "'" + a + (n ? ". " + n : "");
  }
  return (o, a, c) => {
    if (t === !1)
      throw new te(
        s(a, " has been removed" + (r ? " in " + r : "")),
        te.ERR_DEPRECATED
      );
    return r && !uo[a] && (uo[a] = !0, console.warn(
      s(
        a,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), t ? t(o, a, c) : !0;
  };
};
function pf(e, t, r) {
  if (typeof e != "object")
    throw new te("options must be an object", te.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(e);
  let s = n.length;
  for (; s-- > 0; ) {
    const o = n[s], a = t[o];
    if (a) {
      const c = e[o], f = c === void 0 || a(c, o, e);
      if (f !== !0)
        throw new te("option " + o + " must be " + f, te.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new te("Unknown option " + o, te.ERR_BAD_OPTION);
  }
}
const En = {
  assertOptions: pf,
  validators: ms
}, rt = En.validators;
class Hr {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new so(),
      response: new so()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(t, r) {
    typeof t == "string" ? (r = r || {}, r.url = t) : r = t || {}, r = At(this.defaults, r);
    const { transitional: n, paramsSerializer: s, headers: o } = r;
    n !== void 0 && En.assertOptions(n, {
      silentJSONParsing: rt.transitional(rt.boolean),
      forcedJSONParsing: rt.transitional(rt.boolean),
      clarifyTimeoutError: rt.transitional(rt.boolean)
    }, !1), s != null && (I.isFunction(s) ? r.paramsSerializer = {
      serialize: s
    } : En.assertOptions(s, {
      encode: rt.function,
      serialize: rt.function
    }, !0)), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let a;
    a = o && I.merge(
      o.common,
      o[r.method]
    ), a && I.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (h) => {
        delete o[h];
      }
    ), r.headers = Xe.concat(a, o);
    const c = [];
    let f = !0;
    this.interceptors.request.forEach(function(y) {
      typeof y.runWhen == "function" && y.runWhen(r) === !1 || (f = f && y.synchronous, c.unshift(y.fulfilled, y.rejected));
    });
    const i = [];
    this.interceptors.response.forEach(function(y) {
      i.push(y.fulfilled, y.rejected);
    });
    let u, l = 0, w;
    if (!f) {
      const h = [io.bind(this), void 0];
      for (h.unshift.apply(h, c), h.push.apply(h, i), w = h.length, u = Promise.resolve(r); l < w; )
        u = u.then(h[l++], h[l++]);
      return u;
    }
    w = c.length;
    let b = r;
    for (l = 0; l < w; ) {
      const h = c[l++], y = c[l++];
      try {
        b = h(b);
      } catch (_) {
        y.call(this, _);
        break;
      }
    }
    try {
      u = io.call(this, b);
    } catch (h) {
      return Promise.reject(h);
    }
    for (l = 0, w = i.length; l < w; )
      u = u.then(i[l++], i[l++]);
    return u;
  }
  getUri(t) {
    t = At(this.defaults, t);
    const r = wa(t.baseURL, t.url);
    return ga(r, t.params, t.paramsSerializer);
  }
}
I.forEach(["delete", "get", "head", "options"], function(t) {
  Hr.prototype[t] = function(r, n) {
    return this.request(At(n || {}, {
      method: t,
      url: r,
      data: (n || {}).data
    }));
  };
});
I.forEach(["post", "put", "patch"], function(t) {
  function r(n) {
    return function(o, a, c) {
      return this.request(At(c || {}, {
        method: t,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: o,
        data: a
      }));
    };
  }
  Hr.prototype[t] = r(), Hr.prototype[t + "Form"] = r(!0);
});
const Ir = Hr;
class ys {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(o) {
      r = o;
    });
    const n = this;
    this.promise.then((s) => {
      if (!n._listeners)
        return;
      let o = n._listeners.length;
      for (; o-- > 0; )
        n._listeners[o](s);
      n._listeners = null;
    }), this.promise.then = (s) => {
      let o;
      const a = new Promise((c) => {
        n.subscribe(c), o = c;
      }).then(s);
      return a.cancel = function() {
        n.unsubscribe(o);
      }, a;
    }, t(function(o, a, c) {
      n.reason || (n.reason = new pr(o, a, c), r(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(t);
    r !== -1 && this._listeners.splice(r, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new ys(function(s) {
        t = s;
      }),
      cancel: t
    };
  }
}
const hf = ys;
function mf(e) {
  return function(r) {
    return e.apply(null, r);
  };
}
function yf(e) {
  return I.isObject(e) && e.isAxiosError === !0;
}
const Sn = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Sn).forEach(([e, t]) => {
  Sn[t] = e;
});
const gf = Sn;
function Ea(e) {
  const t = new Ir(e), r = oa(Ir.prototype.request, t);
  return I.extend(r, Ir.prototype, t, { allOwnKeys: !0 }), I.extend(r, t, null, { allOwnKeys: !0 }), r.create = function(s) {
    return Ea(At(e, s));
  }, r;
}
const ye = Ea(hs);
ye.Axios = Ir;
ye.CanceledError = pr;
ye.CancelToken = hf;
ye.isCancel = _a;
ye.VERSION = ba;
ye.toFormData = Yr;
ye.AxiosError = te;
ye.Cancel = ye.CanceledError;
ye.all = function(t) {
  return Promise.all(t);
};
ye.spread = mf;
ye.isAxiosError = yf;
ye.mergeConfig = At;
ye.AxiosHeaders = Xe;
ye.formToJSON = (e) => $a(I.isHTMLForm(e) ? new FormData(e) : e);
ye.HttpStatusCode = gf;
ye.default = ye;
const Sa = ye;
Sa.interceptors.request.use(function(e) {
  return e.url += "?dev=1", e;
}, function(e) {
  return Promise.reject(e);
});
function _f(e) {
  function t(r, n) {
    const s = Yo(n), o = me.dirname(s);
    return r.basePath = o, r.id = s, r;
  }
  return {
    name: "transform-world",
    transform(r, n) {
      if (n.endsWith(".world")) {
        const s = t(JSON.parse(r), n);
        return {
          code: `export default ${JSON.stringify(s)}`,
          map: null
        };
      }
    },
    configureServer(r) {
      r.watcher.add(Wl()), r.watcher.on("change", async (n) => {
        if (n.endsWith("world")) {
          Kl(`File ${n} changed, updating world...`);
          const s = _e.readFileSync(n, "utf-8"), o = t(JSON.parse(s), n);
          Sa.put(e + "/api/worlds", {
            worldId: o.id,
            data: o
          }).catch(Gl);
        }
      });
    }
  };
}
export {
  vf as autoLoad,
  $f as flagTransform,
  _f as worldTransformPlugin
};
